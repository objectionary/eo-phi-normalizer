One of the most critical factors affecting software maintainability is
its complexity. The design of a programming language may either
encourage programmers to write code with lower complexity, or
do the opposite and provoke the creation of code with higher
complexity. The following design patterns, also known as anti-patterns, increase complexity,
especially if being used by less experienced programmers
(most critical are at the top of the list):

\newcounter{pattern}
\newcommand{\pattern}[1]{\item P\refstepcounter{pattern}\thepattern\label{ptn:#1}: }
\newcommand{\solution}[1]{
  \item \foreach \r [count=\i] in {#1} {%
    \ifnum\i=1%
      % nothing
    \else%
      , %
    \fi%
    P\ref{ptn:\r}%
  } $\to$
}

\begin{itemize}
\pattern{return-null} Returning NULL references in case of error \\ \citep{hoare2009null}
\pattern{inheritance} Implementation inheritance (esp. multiple) \\ \citep{holub2003extends}
\pattern{mutable} Mutable objects with side-effects \\ \citep{bloch2016effective}
\pattern{casting} Type casting \\ \citep{mcconnell2004codecomplete, gannimo2017typeconfusion}
\pattern{utility} Utility classes with only static methods \\ \citep{eo1}
\pattern{reflection} Runtime reflection on types \\ \citep{eo1}
\pattern{setters} Setters to modify object's data \\ \citep{holub2004more}
\pattern{accept-null} Accepting NULL as function arguments \\ \citep{hoare2009null}
\pattern{global} Global variables and functions \\ \citep{mcconnell2004codecomplete}
\pattern{singleton} Singletons \\ \citep{nystrom2014game, eo1}
\pattern{factory} Factory methods instead of constructors \\ \citep{eo1}
\pattern{swallowing} Exception swallowing \\ \citep{rocha2018javaexception}
\pattern{getters} Getters to retrieve object's data \\ \citep{holub2004more}
\pattern{mixins} Code reuse via mixins (we can think of this as a special case of workaround for the lack of multiple inheritance) \\ \citep{mcconnell2004codecomplete}
\pattern{comments} Explanation of logic via comments \\ \citep{martin2008cleancode,mcconnell2004codecomplete}
\pattern{temporal} Temporal coupling between statements \\ \citep{eo1}
\pattern{formatting} Frivolous inconsistent code formatting \\ \citep{martin2008cleancode,mcconnell2004codecomplete}
\end{itemize}

In Java, C++, Ruby, Python, Smalltalk, JavaScript,
PHP, C\#, Eiffel, Kotlin, Erlang, and other languages most
of the design patterns listed above are possible and may be
utilized by programmers in their code, letting them write
code with higher complexity. To the contrary, they
are not permitted in \eo{} by design:

\begin{itemize}
\solution{return-null,accept-null} There are no NULLs in~\eo{}
\solution{utility,factory,singleton} There are no static methods
\solution{inheritance} There is no inheritance
\solution{mutable,setters} There are no mutable objects
\solution{casting,reflection} There are no types
\solution{global} There is no global scope
\solution{swallowing} There are no exceptions
\solution{mixins} There are no mixins
\solution{comments} Inline comments are prohibited
\solution{temporal} There are no statements
\solution{formatting} The syntax explicitly defines style
\end{itemize}

Thus, since in \eo{} all patterns listed above
are not permitted by the language design, \eo{} programs
will have lower complexity while being written by the same group
of programmers.
