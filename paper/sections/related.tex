Attempts were made to formalize OOP and introduce object calculus,
similar to lambda calculus~\citep{barendregt2012} used in functional programming.
For example, \citet{abadi1995imperative} suggested an imperative calculus of objects,
which was extended by~\citet{bono1998imperative} to support classes,
by~\citet{gordon1998concurrent} to support concurrency and synchronisation,
and by~\citet{jeffrey1999distributed} to support distributed programming.

Earlier, \citet{honda1991object} combined OOP and $\pi$-calculus in order to
introduce object calculus for asynchronous communication, which was further
referenced by~\citet{jones1993pi} in their work on object-based design notation.

A few attempts were made to reduce existing OOP languages
and formalize what is left. Featherweight Java is the most notable example
proposed by~\citet{igarashi2001featherweight}, which is
omitting almost all features of the full language (including interfaces and
even assignment) to obtain a small calculus.
Later it was extended by~\citet{jagannathan2005transactional} to support
nested and multi-threaded transactions. Featherweight Java is used in formal languages
such Obsidian~\citep{coblenz2019} and SJF~\citep{usov2020}.

Another example is Larch/C++~\citep{cheon1994quick}, which is a formal
algebraic interface
specification language tailored to C++. It allows interfaces of C++ classes and
functions to be documented in a way that is unambiguous and concise.

Several attempts to formalize OOP were made by extensions of the most popular
formal notations and methods, such as Object-Z~\citep{duke1991object} and
VDM++~\citep{durr1992vdm}. In
Object-Z, state and operation schemes are encapsulated into classes. The formal
model is based upon the idea of a class history~\citep{duke1990towards}.
Although, all these OO extensions do not have comprehensive
refinement rules that can be used to transform specifications into implemented
code in an actual OO programming language, as was noted by~\citet{paige1999object}.

\citet{bancilhon1985calculus} suggested an object calculus as an extension
to relational calculus. \citet{jankowska2003anotheroop} further developed
these ideas and related them to a Boolean algebra.
\citet{leekwakryu1996transform} developed an algorithm
to transform an object calculus into an object algebra.

However, all these theoretical attempts to formalize OO languages
were not able to fully describe their features, as was noted
by~\citet{nierstrasz1991towards}:
``The development of concurrent object-based programming languages
has suffered from the lack of any generally accepted formal
foundations for defining their semantics.'' In addition, when describing the
attempts of formalization, \citet{eden2002visual} summarized: ``Not one of the
notations is defined formally, nor provided with
\nospell{denotational} semantics,
nor founded on axiomatic semantics.''
%
Moreover, despite these efforts,
\citet{ciaffaglione2003reasoning,ciaffaglione2003typetheories,ciaffaglione2007theory_of_contexts}
noted in their series of works that a relatively little formal work has
been carried out on object-based languages and it remains true to this day.

