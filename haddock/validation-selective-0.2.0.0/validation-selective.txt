-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Lighweight pure data validation based on Applicative and Selective functors
--   
--   Lighweight pure data validation based on Applicative and Selective
--   functors. The library builds validation interface around the following
--   data type:
--   
--   <pre>
--   <b>data</b> Validation e a
--       = Failure e
--       | Success a
--   </pre>
@package validation-selective
@version 0.2.0.0


-- | Helpful combinators to work with <a>Validation</a> data type.
module Validation.Combinators

-- | Validate all given checks in a <a>Foldable</a>. Returns the
--   <a>Success</a> of the start element when all checks are successful.
--   
--   A basic example of usage could look like this:
--   
--   <pre>
--   &gt; <b>let</b> validatePassword = <a>validateAll</a>
--           [ validateEmptyPassword
--           , validateShortPassword
--           ]
--   
--   &gt; <a>validateAll</a> "VeryStrongPassword"
--   <a>Success</a> "VeryStrongPassword"
--   
--   &gt; <a>validateAll</a> ""
--   <a>Failure</a> (EmptyPassword :| [ShortPassword])
--   </pre>
validateAll :: forall e b a f. (Foldable f, Semigroup e) => f (a -> Validation e b) -> a -> Validation e a

-- | Applies the given action to <a>Validation</a> if it is <a>Success</a>
--   and returns the result. In case of <a>Failure</a> the default value is
--   returned.
--   
--   <pre>
--   &gt;&gt;&gt; whenSuccess "bar" (Failure "foo") (\a -&gt; "success!" &lt;$ print a)
--   "bar"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; whenSuccess "bar" (Success 42) (\a -&gt; "success!" &lt;$ print a)
--   42
--   "success!"
--   </pre>
whenSuccess :: Applicative f => x -> Validation e a -> (a -> f x) -> f x

-- | Applies the given action to <a>Validation</a> if it is <a>Failure</a>
--   and returns the result. In case of <a>Success</a> the default value is
--   returned.
--   
--   <pre>
--   &gt;&gt;&gt; whenFailure "bar" (Failure 42) (\a -&gt; "foo" &lt;$ print a)
--   42
--   "foo"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; whenFailure "bar" (Success 42) (\a -&gt; "foo" &lt;$ print a)
--   "bar"
--   </pre>
whenFailure :: Applicative f => x -> Validation e a -> (e -> f x) -> f x

-- | Applies given action to the <a>Validation</a> content if it is
--   <a>Success</a>.
--   
--   Similar to <a>whenSuccess</a> but the default value is <tt>()</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; whenSuccess_ (Failure "foo") print
--   
--   &gt;&gt;&gt; whenSuccess_ (Success 42) print
--   42
--   </pre>
whenSuccess_ :: Applicative f => Validation e a -> (a -> f ()) -> f ()

-- | Applies given action to the <a>Validation</a> content if it is
--   <a>Failure</a>.
--   
--   Similar to <a>whenFailure</a> but the default value is <tt>()</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; whenFailure_ (Success 42) putStrLn
--   
--   &gt;&gt;&gt; whenFailure_ (Failure "foo") putStrLn
--   foo
--   </pre>
whenFailure_ :: Applicative f => Validation e a -> (e -> f ()) -> f ()

-- | Monadic version of <a>whenSuccess</a>. Applies monadic action to the
--   given <a>Validation</a> in case of <a>Success</a>. Returns the
--   resulting value, or provided default.
--   
--   <pre>
--   &gt;&gt;&gt; whenSuccessM "bar" (pure $ Failure "foo") (\a -&gt; "success!" &lt;$ print a)
--   "bar"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; whenSuccessM "bar" (pure $ Success 42) (\a -&gt; "success!" &lt;$ print a)
--   42
--   "success!"
--   </pre>
whenSuccessM :: Monad m => x -> m (Validation e a) -> (a -> m x) -> m x

-- | Monadic version of <a>whenFailure</a>. Applies monadic action to the
--   given <a>Validation</a> in case of <a>Failure</a>. Returns the
--   resulting value, or provided default.
--   
--   <pre>
--   &gt;&gt;&gt; whenFailureM "bar" (pure $ Failure 42) (\a -&gt; "foo" &lt;$ print a)
--   42
--   "foo"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; whenFailureM "bar" (pure $ Success 42) (\a -&gt; "foo" &lt;$ print a)
--   "bar"
--   </pre>
whenFailureM :: Monad m => x -> m (Validation e a) -> (e -> m x) -> m x

-- | Monadic version of <a>whenSuccess_</a>. Applies monadic action to the
--   given <a>Validation</a> in case of <a>Success</a>. Similar to
--   <a>whenSuccessM</a> but the default is <tt>()</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; whenSuccessM_ (pure $ Failure "foo") print
--   
--   &gt;&gt;&gt; whenSuccessM_ (pure $ Success 42) print
--   42
--   </pre>
whenSuccessM_ :: Monad m => m (Validation e a) -> (a -> m ()) -> m ()

-- | Monadic version of <a>whenFailure_</a>. Applies monadic action to the
--   given <a>Validation</a> in case of <a>Failure</a>. Similar to
--   <a>whenFailureM</a> but the default is <tt>()</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; whenFailureM_ (pure $ Success 42) putStrLn
--   
--   &gt;&gt;&gt; whenFailureM_ (pure $ Failure "foo") putStrLn
--   foo
--   </pre>
whenFailureM_ :: Monad m => m (Validation e a) -> (e -> m ()) -> m ()

-- | Maps <a>Failure</a> of <a>Validation</a> to <a>Just</a>.
--   
--   <pre>
--   &gt;&gt;&gt; failureToMaybe (Failure True)
--   Just True
--   
--   &gt;&gt;&gt; failureToMaybe (Success "aba")
--   Nothing
--   </pre>
failureToMaybe :: Validation e a -> Maybe e

-- | Maps <a>Success</a> of <a>Validation</a> to <a>Just</a>.
--   
--   <pre>
--   &gt;&gt;&gt; successToMaybe (Failure True)
--   Nothing
--   
--   &gt;&gt;&gt; successToMaybe (Success "aba")
--   Just "aba"
--   </pre>
successToMaybe :: Validation e a -> Maybe a

-- | Maps <a>Just</a> to <a>Failure</a> In case of <a>Nothing</a> it wraps
--   the given default value into <a>Success</a>.
--   
--   <pre>
--   &gt;&gt;&gt; maybeToFailure True (Just "aba")
--   Failure "aba"
--   
--   &gt;&gt;&gt; maybeToFailure True Nothing
--   Success True
--   </pre>
maybeToFailure :: a -> Maybe e -> Validation e a

-- | Maps <a>Just</a> to <a>Success</a>. In case of <a>Nothing</a> it wraps
--   the given default value into <a>Failure</a>
--   
--   <pre>
--   &gt;&gt;&gt; maybeToSuccess True (Just "aba")
--   Success "aba"
--   
--   &gt;&gt;&gt; maybeToSuccess True Nothing
--   Failure True
--   </pre>
maybeToSuccess :: e -> Maybe a -> Validation e a


-- | Lightweight pure data validation based on <a>Applicative</a> and
--   <a>Selective</a> functors.
--   
--   <a>Validation</a> allows to accumulate all errors instead of
--   short-circuting on the first error so you can display all possible
--   errors at once.
--   
--   Common use-cases include:
--   
--   <ol>
--   <li>Validating each input of a form with multiple inputs.</li>
--   <li>Performing multiple validations of a single value.</li>
--   </ol>
--   
--   <a>Validation</a> provides <b>modular</b> and <b>composable</b>
--   interface which means that you can implement validations for different
--   pieces of your data independently, and then combine smaller parts into
--   the validation of a bigger type. The below table illustrates main ways
--   to combine two <a>Validation</a>s:
--   
--   TODO: table
--   
--   In other words, instances of different standard typeclasses provide
--   various semantics which can be useful in different use-cases:
--   
--   <ol>
--   <li><a>Semigroup</a>: accumulate both <a>Failure</a> and
--   <a>Success</a> with <a>&lt;&gt;</a>.</li>
--   <li><a>Monoid</a>: <a>Success</a> that stores <a>mempty</a>.</li>
--   <li><a>Functor</a>: change the type inside <a>Success</a>.</li>
--   <li><a>Bifunctor</a>: change both <a>Failure</a> and
--   <a>Success</a>.</li>
--   <li><a>Applicative</a>: apply function to values inside <a>Success</a>
--   and accumulate errors inside <a>Failure</a>.</li>
--   <li><a>Alternative</a>: return the first <a>Success</a> or accumulate
--   all errors inside <a>Failure</a>.</li>
--   <li><a>Selective</a>: choose which validations to apply based on the
--   value inside.</li>
--   </ol>
module Validation

-- | <a>Validation</a> is a polymorphic sum type for storing either all
--   validation failures or validation success. Unlike <a>Either</a>, which
--   returns only the first error, <a>Validation</a> accumulates all errors
--   using the <a>Semigroup</a> typeclass.
--   
--   Usually type variables in <tt><a>Validation</a> e a</tt> are used as
--   follows:
--   
--   <ul>
--   <li><tt>e</tt>: is a list or set of failure messages or values of some
--   error data type.</li>
--   <li><tt>a</tt>: is some domain type denoting successful validation
--   result.</li>
--   </ul>
--   
--   Some typical use-cases:
--   
--   <ul>
--   <li><pre><a>Validation</a> [<a>String</a>] User</pre><ul><li>Either
--   list of <a>String</a> error messages or a validated value of a custom
--   <tt>User</tt> type.</li></ul></li>
--   <li><pre><a>Validation</a> (<a>NonEmpty</a> UserValidationError)
--   User</pre><ul><li>Similar to previous example, but list of failures
--   guaranteed to be non-empty in case of validation failure, and it
--   stores values of some custom error type.</li></ul></li>
--   </ul>
data Validation e a

-- | Validation failure. The <tt>e</tt> type is supposed to implement the
--   <a>Semigroup</a> instance.
Failure :: e -> Validation e a

-- | Successful validation result of type <tt>a</tt>.
Success :: a -> Validation e a

-- | Predicate on if the given <a>Validation</a> is <a>Failure</a>.
--   
--   <pre>
--   &gt;&gt;&gt; isFailure (Failure 'e')
--   True
--   
--   &gt;&gt;&gt; isFailure (Success 'a')
--   False
--   </pre>
isFailure :: Validation e a -> Bool

-- | Predicate on if the given <a>Validation</a> is <a>Success</a>.
--   
--   <pre>
--   &gt;&gt;&gt; isSuccess (Success 'a')
--   True
--   
--   &gt;&gt;&gt; isSuccess (Failure 'e')
--   False
--   </pre>
isSuccess :: Validation e a -> Bool

-- | Transforms the value of the given <a>Validation</a> into <tt>x</tt>
--   using provided functions that can transform <a>Failure</a> and
--   <a>Success</a> value into the resulting type respectively.
--   
--   <pre>
--   &gt;&gt;&gt; let myValidation = validation (&lt;&gt; " world!") (show . (* 10))
--   
--   &gt;&gt;&gt; myValidation (Success 100)
--   "1000"
--   
--   &gt;&gt;&gt; myValidation (Failure "Hello")
--   "Hello world!"
--   </pre>
validation :: (e -> x) -> (a -> x) -> Validation e a -> x

-- | Filters out all <a>Failure</a> values into the new list of <tt>e</tt>s
--   from the given list of <a>Validation</a>s.
--   
--   Note that the order is preserved.
--   
--   <pre>
--   &gt;&gt;&gt; failures [Failure "Hello", Success 1, Failure "world", Success 2, Failure "!" ]
--   ["Hello","world","!"]
--   </pre>
failures :: [Validation e a] -> [e]

-- | Filters out all <a>Success</a> values into the new list of <tt>a</tt>s
--   from the given list of <a>Validation</a>s.
--   
--   Note that the order is preserved.
--   
--   <pre>
--   &gt;&gt;&gt; successes [Failure "Hello", Success 1, Failure "world", Success 2, Failure "!" ]
--   [1,2]
--   </pre>
successes :: [Validation e a] -> [a]

-- | Redistributes the given list of <a>Validation</a>s into two lists of
--   <tt>e</tt>s and <tt>e</tt>s, where the first list contains all values
--   of <a>Failure</a>s and the second one — <a>Success</a>es
--   correspondingly.
--   
--   Note that the order is preserved.
--   
--   <pre>
--   &gt;&gt;&gt; partitionValidations [Failure "Hello", Success 1, Failure "world", Success 2, Failure "!" ]
--   (["Hello","world","!"],[1,2])
--   </pre>
partitionValidations :: [Validation e a] -> ([e], [a])

-- | Returns the contents of a <a>Failure</a>-value or a default value
--   otherwise.
--   
--   <pre>
--   &gt;&gt;&gt; fromFailure "default" (Failure "failure")
--   "failure"
--   
--   &gt;&gt;&gt; fromFailure "default" (Success 1)
--   "default"
--   </pre>
fromFailure :: e -> Validation e a -> e

-- | Returns the contents of a <a>Success</a>-value or a default value
--   otherwise.
--   
--   <pre>
--   &gt;&gt;&gt; fromSuccess 42 (Success 1)
--   1
--   
--   &gt;&gt;&gt; fromSuccess 42 (Failure "failure")
--   42
--   </pre>
fromSuccess :: a -> Validation e a -> a

-- | Create a <a>Failure</a> of <a>NonEmpty</a> list with a single given
--   error.
--   
--   <pre>
--   &gt;&gt;&gt; failure "I am a failure"
--   Failure ("I am a failure" :| [])
--   </pre>
failure :: e -> Validation (NonEmpty e) a

-- | Returns a <a>Failure</a> in case of the given predicate is
--   <a>True</a>. Returns <tt><a>Success</a> ()</tt> otherwise.
--   
--   <pre>
--   &gt;&gt;&gt; let shouldFail = (==) "I am a failure"
--   
--   &gt;&gt;&gt; failureIf (shouldFail "I am a failure") "I told you so"
--   Failure ("I told you so" :| [])
--   
--   &gt;&gt;&gt; failureIf (shouldFail "I am NOT a failure") "okay"
--   Success ()
--   </pre>
failureIf :: Bool -> e -> Validation (NonEmpty e) ()

-- | Returns a <a>Failure</a> unless the given predicate is <a>True</a>.
--   Returns <tt><a>Success</a> ()</tt> in case of the predicate is
--   satisfied.
--   
--   Similar to <a>failureIf</a> with the reversed predicate.
--   
--   <pre>
--   <a>failureUnless</a> p ≡ <a>failureIf</a> (not p)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let shouldFail = (==) "I am a failure"
--   
--   &gt;&gt;&gt; failureUnless (shouldFail "I am a failure") "doesn't matter"
--   Success ()
--   
--   &gt;&gt;&gt; failureUnless (shouldFail "I am NOT a failure") "I told you so"
--   Failure ("I told you so" :| [])
--   </pre>
failureUnless :: Bool -> e -> Validation (NonEmpty e) ()

-- | Transform a <a>Validation</a> into an <a>Either</a>.
--   
--   <pre>
--   &gt;&gt;&gt; validationToEither (Success "whoop")
--   Right "whoop"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; validationToEither (Failure "nahh")
--   Left "nahh"
--   </pre>
validationToEither :: Validation e a -> Either e a

-- | Transform an <a>Either</a> into a <a>Validation</a>.
--   
--   <pre>
--   &gt;&gt;&gt; eitherToValidation (Right "whoop")
--   Success "whoop"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; eitherToValidation (Left "nahh")
--   Failure "nahh"
--   </pre>
eitherToValidation :: Either e a -> Validation e a

-- | Validate all given checks in a <a>Foldable</a>. Returns the
--   <a>Success</a> of the start element when all checks are successful.
--   
--   A basic example of usage could look like this:
--   
--   <pre>
--   &gt; <b>let</b> validatePassword = <a>validateAll</a>
--           [ validateEmptyPassword
--           , validateShortPassword
--           ]
--   
--   &gt; <a>validateAll</a> "VeryStrongPassword"
--   <a>Success</a> "VeryStrongPassword"
--   
--   &gt; <a>validateAll</a> ""
--   <a>Failure</a> (EmptyPassword :| [ShortPassword])
--   </pre>
validateAll :: forall e b a f. (Foldable f, Semigroup e) => f (a -> Validation e b) -> a -> Validation e a

-- | Applies the given action to <a>Validation</a> if it is <a>Success</a>
--   and returns the result. In case of <a>Failure</a> the default value is
--   returned.
--   
--   <pre>
--   &gt;&gt;&gt; whenSuccess "bar" (Failure "foo") (\a -&gt; "success!" &lt;$ print a)
--   "bar"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; whenSuccess "bar" (Success 42) (\a -&gt; "success!" &lt;$ print a)
--   42
--   "success!"
--   </pre>
whenSuccess :: Applicative f => x -> Validation e a -> (a -> f x) -> f x

-- | Applies the given action to <a>Validation</a> if it is <a>Failure</a>
--   and returns the result. In case of <a>Success</a> the default value is
--   returned.
--   
--   <pre>
--   &gt;&gt;&gt; whenFailure "bar" (Failure 42) (\a -&gt; "foo" &lt;$ print a)
--   42
--   "foo"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; whenFailure "bar" (Success 42) (\a -&gt; "foo" &lt;$ print a)
--   "bar"
--   </pre>
whenFailure :: Applicative f => x -> Validation e a -> (e -> f x) -> f x

-- | Applies given action to the <a>Validation</a> content if it is
--   <a>Success</a>.
--   
--   Similar to <a>whenSuccess</a> but the default value is <tt>()</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; whenSuccess_ (Failure "foo") print
--   
--   &gt;&gt;&gt; whenSuccess_ (Success 42) print
--   42
--   </pre>
whenSuccess_ :: Applicative f => Validation e a -> (a -> f ()) -> f ()

-- | Applies given action to the <a>Validation</a> content if it is
--   <a>Failure</a>.
--   
--   Similar to <a>whenFailure</a> but the default value is <tt>()</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; whenFailure_ (Success 42) putStrLn
--   
--   &gt;&gt;&gt; whenFailure_ (Failure "foo") putStrLn
--   foo
--   </pre>
whenFailure_ :: Applicative f => Validation e a -> (e -> f ()) -> f ()

-- | Monadic version of <a>whenSuccess</a>. Applies monadic action to the
--   given <a>Validation</a> in case of <a>Success</a>. Returns the
--   resulting value, or provided default.
--   
--   <pre>
--   &gt;&gt;&gt; whenSuccessM "bar" (pure $ Failure "foo") (\a -&gt; "success!" &lt;$ print a)
--   "bar"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; whenSuccessM "bar" (pure $ Success 42) (\a -&gt; "success!" &lt;$ print a)
--   42
--   "success!"
--   </pre>
whenSuccessM :: Monad m => x -> m (Validation e a) -> (a -> m x) -> m x

-- | Monadic version of <a>whenFailure</a>. Applies monadic action to the
--   given <a>Validation</a> in case of <a>Failure</a>. Returns the
--   resulting value, or provided default.
--   
--   <pre>
--   &gt;&gt;&gt; whenFailureM "bar" (pure $ Failure 42) (\a -&gt; "foo" &lt;$ print a)
--   42
--   "foo"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; whenFailureM "bar" (pure $ Success 42) (\a -&gt; "foo" &lt;$ print a)
--   "bar"
--   </pre>
whenFailureM :: Monad m => x -> m (Validation e a) -> (e -> m x) -> m x

-- | Monadic version of <a>whenSuccess_</a>. Applies monadic action to the
--   given <a>Validation</a> in case of <a>Success</a>. Similar to
--   <a>whenSuccessM</a> but the default is <tt>()</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; whenSuccessM_ (pure $ Failure "foo") print
--   
--   &gt;&gt;&gt; whenSuccessM_ (pure $ Success 42) print
--   42
--   </pre>
whenSuccessM_ :: Monad m => m (Validation e a) -> (a -> m ()) -> m ()

-- | Monadic version of <a>whenFailure_</a>. Applies monadic action to the
--   given <a>Validation</a> in case of <a>Failure</a>. Similar to
--   <a>whenFailureM</a> but the default is <tt>()</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; whenFailureM_ (pure $ Success 42) putStrLn
--   
--   &gt;&gt;&gt; whenFailureM_ (pure $ Failure "foo") putStrLn
--   foo
--   </pre>
whenFailureM_ :: Monad m => m (Validation e a) -> (e -> m ()) -> m ()

-- | Maps <a>Failure</a> of <a>Validation</a> to <a>Just</a>.
--   
--   <pre>
--   &gt;&gt;&gt; failureToMaybe (Failure True)
--   Just True
--   
--   &gt;&gt;&gt; failureToMaybe (Success "aba")
--   Nothing
--   </pre>
failureToMaybe :: Validation e a -> Maybe e

-- | Maps <a>Success</a> of <a>Validation</a> to <a>Just</a>.
--   
--   <pre>
--   &gt;&gt;&gt; successToMaybe (Failure True)
--   Nothing
--   
--   &gt;&gt;&gt; successToMaybe (Success "aba")
--   Just "aba"
--   </pre>
successToMaybe :: Validation e a -> Maybe a

-- | Maps <a>Just</a> to <a>Failure</a> In case of <a>Nothing</a> it wraps
--   the given default value into <a>Success</a>.
--   
--   <pre>
--   &gt;&gt;&gt; maybeToFailure True (Just "aba")
--   Failure "aba"
--   
--   &gt;&gt;&gt; maybeToFailure True Nothing
--   Success True
--   </pre>
maybeToFailure :: a -> Maybe e -> Validation e a

-- | Maps <a>Just</a> to <a>Success</a>. In case of <a>Nothing</a> it wraps
--   the given default value into <a>Failure</a>
--   
--   <pre>
--   &gt;&gt;&gt; maybeToSuccess True (Just "aba")
--   Success "aba"
--   
--   &gt;&gt;&gt; maybeToSuccess True Nothing
--   Failure True
--   </pre>
maybeToSuccess :: e -> Maybe a -> Validation e a
instance Control.DeepSeq.NFData e => Control.DeepSeq.NFData1 (Validation.Validation e)
instance (Control.DeepSeq.NFData e, Control.DeepSeq.NFData a) => Control.DeepSeq.NFData (Validation.Validation e a)
instance (Data.Data.Data e, Data.Data.Data a) => Data.Data.Data (Validation.Validation e a)
instance GHC.Generics.Generic1 (Validation.Validation e)
instance GHC.Generics.Generic (Validation.Validation e a)
instance (GHC.Show.Show e, GHC.Show.Show a) => GHC.Show.Show (Validation.Validation e a)
instance (GHC.Classes.Ord e, GHC.Classes.Ord a) => GHC.Classes.Ord (Validation.Validation e a)
instance (GHC.Classes.Eq e, GHC.Classes.Eq a) => GHC.Classes.Eq (Validation.Validation e a)
instance (Validation.NoValidationMonadError, GHC.Base.Semigroup e) => GHC.Base.Monad (Validation.Validation e)
instance GHC.Base.Functor (Validation.Validation e)
instance (GHC.Base.Semigroup e, GHC.Base.Semigroup a) => GHC.Base.Semigroup (Validation.Validation e a)
instance (GHC.Base.Semigroup e, GHC.Base.Monoid a) => GHC.Base.Monoid (Validation.Validation e a)
instance GHC.Base.Semigroup e => GHC.Base.Applicative (Validation.Validation e)
instance GHC.Base.Semigroup e => Control.Selective.Selective (Validation.Validation e)
instance GHC.Base.Monoid e => GHC.Base.Alternative (Validation.Validation e)
instance Data.Foldable.Foldable (Validation.Validation e)
instance Data.Traversable.Traversable (Validation.Validation e)
instance Data.Bifunctor.Bifunctor Validation.Validation
instance Data.Bifoldable.Bifoldable Validation.Validation
instance Data.Bitraversable.Bitraversable Validation.Validation
instance Control.DeepSeq.NFData2 Validation.Validation
