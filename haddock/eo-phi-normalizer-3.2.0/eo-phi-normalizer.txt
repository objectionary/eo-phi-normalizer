-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Command line normalizer of ùúë-calculus expressions.
--   
--   Please see the README on GitHub at
--   <a>https://github.com/objectionary/eo-phi-normalizer#readme</a>
@package eo-phi-normalizer
@version 3.2.0

module Language.EO.Locale
withCorrectLocale :: IO a -> IO a


-- | The abstract syntax of language Syntax.
module Language.EO.Phi.Syntax.Abs
data Program
Program :: [Binding] -> Program
data MetaId
MetaIdLabel :: LabelMetaId -> MetaId
MetaIdTail :: TailMetaId -> MetaId
MetaIdBindings :: BindingsMetaId -> MetaId
MetaIdObject :: ObjectMetaId -> MetaId
MetaIdBytes :: BytesMetaId -> MetaId
data Object
Formation :: [Binding] -> Object
Application :: Object -> [Binding] -> Object
ObjectDispatch :: Object -> Attribute -> Object
GlobalObject :: Object
GlobalObjectPhiOrg :: Object
ThisObject :: Object
Termination :: Object
ConstStringRaw :: StringRaw -> Object
ConstIntRaw :: IntegerSigned -> Object
ConstFloatRaw :: DoubleSigned -> Object
MetaSubstThis :: Object -> Object -> Object
MetaContextualize :: Object -> Object -> Object
MetaObject :: ObjectMetaId -> Object
MetaTailContext :: Object -> TailMetaId -> Object
MetaFunction :: MetaFunctionName -> Object -> Object
ConstFloat :: Double -> Object
ConstInt :: Integer -> Object
ConstString :: String -> Object
data Binding
AlphaBinding :: AttributeSugar -> Object -> Binding
AlphaBindingSugar :: Object -> Binding
EmptyBinding :: Attribute -> Binding
DeltaBinding :: Bytes -> Binding
DeltaEmptyBinding :: Binding
LambdaBinding :: Function -> Binding
MetaBindings :: BindingsMetaId -> Binding
MetaDeltaBinding :: BytesMetaId -> Binding
data AttributeSugar
AttributeNoSugar :: Attribute -> AttributeSugar
AttributeSugar :: LabelId -> [Attribute] -> AttributeSugar
data Attribute
Phi :: Attribute
Rho :: Attribute
Label :: LabelId -> Attribute
Alpha :: AlphaIndex -> Attribute
MetaAttr :: LabelMetaId -> Attribute
data RuleAttribute
ObjectAttr :: Attribute -> RuleAttribute
DeltaAttr :: RuleAttribute
LambdaAttr :: RuleAttribute
data PeeledObject
PeeledObject :: ObjectHead -> [ObjectAction] -> PeeledObject
data ObjectHead
HeadFormation :: [Binding] -> ObjectHead
HeadGlobal :: ObjectHead
HeadThis :: ObjectHead
HeadTermination :: ObjectHead
data ObjectAction
ActionApplication :: [Binding] -> ObjectAction
ActionDispatch :: Attribute -> ObjectAction
newtype Bytes
Bytes :: String -> Bytes
newtype Function
Function :: String -> Function
newtype LabelId
LabelId :: String -> LabelId
newtype AlphaIndex
AlphaIndex :: String -> AlphaIndex
newtype LabelMetaId
LabelMetaId :: String -> LabelMetaId
newtype TailMetaId
TailMetaId :: String -> TailMetaId
newtype BindingsMetaId
BindingsMetaId :: String -> BindingsMetaId
newtype ObjectMetaId
ObjectMetaId :: String -> ObjectMetaId
newtype BytesMetaId
BytesMetaId :: String -> BytesMetaId
newtype MetaFunctionName
MetaFunctionName :: String -> MetaFunctionName
newtype IntegerSigned
IntegerSigned :: String -> IntegerSigned
newtype DoubleSigned
DoubleSigned :: String -> DoubleSigned
newtype StringRaw
StringRaw :: String -> StringRaw
instance Data.String.IsString Language.EO.Phi.Syntax.Abs.Bytes
instance GHC.Generics.Generic Language.EO.Phi.Syntax.Abs.Bytes
instance Data.Data.Data Language.EO.Phi.Syntax.Abs.Bytes
instance GHC.Read.Read Language.EO.Phi.Syntax.Abs.Bytes
instance GHC.Show.Show Language.EO.Phi.Syntax.Abs.Bytes
instance GHC.Classes.Ord Language.EO.Phi.Syntax.Abs.Bytes
instance GHC.Classes.Eq Language.EO.Phi.Syntax.Abs.Bytes
instance Data.String.IsString Language.EO.Phi.Syntax.Abs.Function
instance GHC.Generics.Generic Language.EO.Phi.Syntax.Abs.Function
instance Data.Data.Data Language.EO.Phi.Syntax.Abs.Function
instance GHC.Read.Read Language.EO.Phi.Syntax.Abs.Function
instance GHC.Show.Show Language.EO.Phi.Syntax.Abs.Function
instance GHC.Classes.Ord Language.EO.Phi.Syntax.Abs.Function
instance GHC.Classes.Eq Language.EO.Phi.Syntax.Abs.Function
instance Data.String.IsString Language.EO.Phi.Syntax.Abs.LabelId
instance GHC.Generics.Generic Language.EO.Phi.Syntax.Abs.LabelId
instance Data.Data.Data Language.EO.Phi.Syntax.Abs.LabelId
instance GHC.Read.Read Language.EO.Phi.Syntax.Abs.LabelId
instance GHC.Show.Show Language.EO.Phi.Syntax.Abs.LabelId
instance GHC.Classes.Ord Language.EO.Phi.Syntax.Abs.LabelId
instance GHC.Classes.Eq Language.EO.Phi.Syntax.Abs.LabelId
instance Data.String.IsString Language.EO.Phi.Syntax.Abs.AlphaIndex
instance GHC.Generics.Generic Language.EO.Phi.Syntax.Abs.AlphaIndex
instance Data.Data.Data Language.EO.Phi.Syntax.Abs.AlphaIndex
instance GHC.Read.Read Language.EO.Phi.Syntax.Abs.AlphaIndex
instance GHC.Show.Show Language.EO.Phi.Syntax.Abs.AlphaIndex
instance GHC.Classes.Ord Language.EO.Phi.Syntax.Abs.AlphaIndex
instance GHC.Classes.Eq Language.EO.Phi.Syntax.Abs.AlphaIndex
instance Data.String.IsString Language.EO.Phi.Syntax.Abs.LabelMetaId
instance GHC.Generics.Generic Language.EO.Phi.Syntax.Abs.LabelMetaId
instance Data.Data.Data Language.EO.Phi.Syntax.Abs.LabelMetaId
instance GHC.Read.Read Language.EO.Phi.Syntax.Abs.LabelMetaId
instance GHC.Show.Show Language.EO.Phi.Syntax.Abs.LabelMetaId
instance GHC.Classes.Ord Language.EO.Phi.Syntax.Abs.LabelMetaId
instance GHC.Classes.Eq Language.EO.Phi.Syntax.Abs.LabelMetaId
instance GHC.Generics.Generic Language.EO.Phi.Syntax.Abs.Attribute
instance Data.Data.Data Language.EO.Phi.Syntax.Abs.Attribute
instance GHC.Read.Read Language.EO.Phi.Syntax.Abs.Attribute
instance GHC.Show.Show Language.EO.Phi.Syntax.Abs.Attribute
instance GHC.Classes.Ord Language.EO.Phi.Syntax.Abs.Attribute
instance GHC.Classes.Eq Language.EO.Phi.Syntax.Abs.Attribute
instance GHC.Generics.Generic Language.EO.Phi.Syntax.Abs.RuleAttribute
instance Data.Data.Data Language.EO.Phi.Syntax.Abs.RuleAttribute
instance GHC.Read.Read Language.EO.Phi.Syntax.Abs.RuleAttribute
instance GHC.Show.Show Language.EO.Phi.Syntax.Abs.RuleAttribute
instance GHC.Classes.Ord Language.EO.Phi.Syntax.Abs.RuleAttribute
instance GHC.Classes.Eq Language.EO.Phi.Syntax.Abs.RuleAttribute
instance GHC.Generics.Generic Language.EO.Phi.Syntax.Abs.AttributeSugar
instance Data.Data.Data Language.EO.Phi.Syntax.Abs.AttributeSugar
instance GHC.Read.Read Language.EO.Phi.Syntax.Abs.AttributeSugar
instance GHC.Show.Show Language.EO.Phi.Syntax.Abs.AttributeSugar
instance GHC.Classes.Ord Language.EO.Phi.Syntax.Abs.AttributeSugar
instance GHC.Classes.Eq Language.EO.Phi.Syntax.Abs.AttributeSugar
instance Data.String.IsString Language.EO.Phi.Syntax.Abs.TailMetaId
instance GHC.Generics.Generic Language.EO.Phi.Syntax.Abs.TailMetaId
instance Data.Data.Data Language.EO.Phi.Syntax.Abs.TailMetaId
instance GHC.Read.Read Language.EO.Phi.Syntax.Abs.TailMetaId
instance GHC.Show.Show Language.EO.Phi.Syntax.Abs.TailMetaId
instance GHC.Classes.Ord Language.EO.Phi.Syntax.Abs.TailMetaId
instance GHC.Classes.Eq Language.EO.Phi.Syntax.Abs.TailMetaId
instance Data.String.IsString Language.EO.Phi.Syntax.Abs.BindingsMetaId
instance GHC.Generics.Generic Language.EO.Phi.Syntax.Abs.BindingsMetaId
instance Data.Data.Data Language.EO.Phi.Syntax.Abs.BindingsMetaId
instance GHC.Read.Read Language.EO.Phi.Syntax.Abs.BindingsMetaId
instance GHC.Show.Show Language.EO.Phi.Syntax.Abs.BindingsMetaId
instance GHC.Classes.Ord Language.EO.Phi.Syntax.Abs.BindingsMetaId
instance GHC.Classes.Eq Language.EO.Phi.Syntax.Abs.BindingsMetaId
instance Data.String.IsString Language.EO.Phi.Syntax.Abs.ObjectMetaId
instance GHC.Generics.Generic Language.EO.Phi.Syntax.Abs.ObjectMetaId
instance Data.Data.Data Language.EO.Phi.Syntax.Abs.ObjectMetaId
instance GHC.Read.Read Language.EO.Phi.Syntax.Abs.ObjectMetaId
instance GHC.Show.Show Language.EO.Phi.Syntax.Abs.ObjectMetaId
instance GHC.Classes.Ord Language.EO.Phi.Syntax.Abs.ObjectMetaId
instance GHC.Classes.Eq Language.EO.Phi.Syntax.Abs.ObjectMetaId
instance Data.String.IsString Language.EO.Phi.Syntax.Abs.BytesMetaId
instance GHC.Generics.Generic Language.EO.Phi.Syntax.Abs.BytesMetaId
instance Data.Data.Data Language.EO.Phi.Syntax.Abs.BytesMetaId
instance GHC.Read.Read Language.EO.Phi.Syntax.Abs.BytesMetaId
instance GHC.Show.Show Language.EO.Phi.Syntax.Abs.BytesMetaId
instance GHC.Classes.Ord Language.EO.Phi.Syntax.Abs.BytesMetaId
instance GHC.Classes.Eq Language.EO.Phi.Syntax.Abs.BytesMetaId
instance GHC.Generics.Generic Language.EO.Phi.Syntax.Abs.MetaId
instance Data.Data.Data Language.EO.Phi.Syntax.Abs.MetaId
instance GHC.Read.Read Language.EO.Phi.Syntax.Abs.MetaId
instance GHC.Show.Show Language.EO.Phi.Syntax.Abs.MetaId
instance GHC.Classes.Ord Language.EO.Phi.Syntax.Abs.MetaId
instance GHC.Classes.Eq Language.EO.Phi.Syntax.Abs.MetaId
instance Data.String.IsString Language.EO.Phi.Syntax.Abs.MetaFunctionName
instance GHC.Generics.Generic Language.EO.Phi.Syntax.Abs.MetaFunctionName
instance Data.Data.Data Language.EO.Phi.Syntax.Abs.MetaFunctionName
instance GHC.Read.Read Language.EO.Phi.Syntax.Abs.MetaFunctionName
instance GHC.Show.Show Language.EO.Phi.Syntax.Abs.MetaFunctionName
instance GHC.Classes.Ord Language.EO.Phi.Syntax.Abs.MetaFunctionName
instance GHC.Classes.Eq Language.EO.Phi.Syntax.Abs.MetaFunctionName
instance Data.String.IsString Language.EO.Phi.Syntax.Abs.IntegerSigned
instance GHC.Generics.Generic Language.EO.Phi.Syntax.Abs.IntegerSigned
instance Data.Data.Data Language.EO.Phi.Syntax.Abs.IntegerSigned
instance GHC.Read.Read Language.EO.Phi.Syntax.Abs.IntegerSigned
instance GHC.Show.Show Language.EO.Phi.Syntax.Abs.IntegerSigned
instance GHC.Classes.Ord Language.EO.Phi.Syntax.Abs.IntegerSigned
instance GHC.Classes.Eq Language.EO.Phi.Syntax.Abs.IntegerSigned
instance Data.String.IsString Language.EO.Phi.Syntax.Abs.DoubleSigned
instance GHC.Generics.Generic Language.EO.Phi.Syntax.Abs.DoubleSigned
instance Data.Data.Data Language.EO.Phi.Syntax.Abs.DoubleSigned
instance GHC.Read.Read Language.EO.Phi.Syntax.Abs.DoubleSigned
instance GHC.Show.Show Language.EO.Phi.Syntax.Abs.DoubleSigned
instance GHC.Classes.Ord Language.EO.Phi.Syntax.Abs.DoubleSigned
instance GHC.Classes.Eq Language.EO.Phi.Syntax.Abs.DoubleSigned
instance Data.String.IsString Language.EO.Phi.Syntax.Abs.StringRaw
instance GHC.Generics.Generic Language.EO.Phi.Syntax.Abs.StringRaw
instance Data.Data.Data Language.EO.Phi.Syntax.Abs.StringRaw
instance GHC.Read.Read Language.EO.Phi.Syntax.Abs.StringRaw
instance GHC.Show.Show Language.EO.Phi.Syntax.Abs.StringRaw
instance GHC.Classes.Ord Language.EO.Phi.Syntax.Abs.StringRaw
instance GHC.Classes.Eq Language.EO.Phi.Syntax.Abs.StringRaw
instance GHC.Generics.Generic Language.EO.Phi.Syntax.Abs.Binding
instance Data.Data.Data Language.EO.Phi.Syntax.Abs.Binding
instance GHC.Read.Read Language.EO.Phi.Syntax.Abs.Binding
instance GHC.Show.Show Language.EO.Phi.Syntax.Abs.Binding
instance GHC.Classes.Ord Language.EO.Phi.Syntax.Abs.Binding
instance GHC.Classes.Eq Language.EO.Phi.Syntax.Abs.Binding
instance GHC.Generics.Generic Language.EO.Phi.Syntax.Abs.Object
instance Data.Data.Data Language.EO.Phi.Syntax.Abs.Object
instance GHC.Read.Read Language.EO.Phi.Syntax.Abs.Object
instance GHC.Show.Show Language.EO.Phi.Syntax.Abs.Object
instance GHC.Classes.Ord Language.EO.Phi.Syntax.Abs.Object
instance GHC.Classes.Eq Language.EO.Phi.Syntax.Abs.Object
instance GHC.Generics.Generic Language.EO.Phi.Syntax.Abs.ObjectAction
instance Data.Data.Data Language.EO.Phi.Syntax.Abs.ObjectAction
instance GHC.Read.Read Language.EO.Phi.Syntax.Abs.ObjectAction
instance GHC.Show.Show Language.EO.Phi.Syntax.Abs.ObjectAction
instance GHC.Classes.Ord Language.EO.Phi.Syntax.Abs.ObjectAction
instance GHC.Classes.Eq Language.EO.Phi.Syntax.Abs.ObjectAction
instance GHC.Generics.Generic Language.EO.Phi.Syntax.Abs.ObjectHead
instance Data.Data.Data Language.EO.Phi.Syntax.Abs.ObjectHead
instance GHC.Read.Read Language.EO.Phi.Syntax.Abs.ObjectHead
instance GHC.Show.Show Language.EO.Phi.Syntax.Abs.ObjectHead
instance GHC.Classes.Ord Language.EO.Phi.Syntax.Abs.ObjectHead
instance GHC.Classes.Eq Language.EO.Phi.Syntax.Abs.ObjectHead
instance GHC.Generics.Generic Language.EO.Phi.Syntax.Abs.PeeledObject
instance Data.Data.Data Language.EO.Phi.Syntax.Abs.PeeledObject
instance GHC.Read.Read Language.EO.Phi.Syntax.Abs.PeeledObject
instance GHC.Show.Show Language.EO.Phi.Syntax.Abs.PeeledObject
instance GHC.Classes.Ord Language.EO.Phi.Syntax.Abs.PeeledObject
instance GHC.Classes.Eq Language.EO.Phi.Syntax.Abs.PeeledObject
instance GHC.Generics.Generic Language.EO.Phi.Syntax.Abs.Program
instance Data.Data.Data Language.EO.Phi.Syntax.Abs.Program
instance GHC.Read.Read Language.EO.Phi.Syntax.Abs.Program
instance GHC.Show.Show Language.EO.Phi.Syntax.Abs.Program
instance GHC.Classes.Ord Language.EO.Phi.Syntax.Abs.Program
instance GHC.Classes.Eq Language.EO.Phi.Syntax.Abs.Program

module Language.EO.Phi.Pretty
instance Prettyprinter.Internal.Pretty Language.EO.Phi.Syntax.Abs.Bytes
instance Prettyprinter.Internal.Pretty Language.EO.Phi.Syntax.Abs.Function
instance Prettyprinter.Internal.Pretty Language.EO.Phi.Syntax.Abs.LabelId
instance Prettyprinter.Internal.Pretty Language.EO.Phi.Syntax.Abs.AlphaIndex
instance Prettyprinter.Internal.Pretty Language.EO.Phi.Syntax.Abs.LabelMetaId
instance Prettyprinter.Internal.Pretty Language.EO.Phi.Syntax.Abs.TailMetaId
instance Prettyprinter.Internal.Pretty Language.EO.Phi.Syntax.Abs.BindingsMetaId
instance Prettyprinter.Internal.Pretty Language.EO.Phi.Syntax.Abs.ObjectMetaId
instance Prettyprinter.Internal.Pretty Language.EO.Phi.Syntax.Abs.BytesMetaId
instance Prettyprinter.Internal.Pretty Language.EO.Phi.Syntax.Abs.MetaFunctionName
instance Prettyprinter.Internal.Pretty Language.EO.Phi.Syntax.Abs.IntegerSigned
instance Prettyprinter.Internal.Pretty Language.EO.Phi.Syntax.Abs.DoubleSigned
instance Prettyprinter.Internal.Pretty Language.EO.Phi.Syntax.Abs.StringRaw
instance Prettyprinter.Internal.Pretty Language.EO.Phi.Syntax.Abs.Program
instance Prettyprinter.Internal.Pretty Language.EO.Phi.Syntax.Abs.MetaId
instance Prettyprinter.Internal.Pretty Language.EO.Phi.Syntax.Abs.Object
instance Prettyprinter.Internal.Pretty Language.EO.Phi.Syntax.Abs.Binding
instance Prettyprinter.Internal.Pretty Language.EO.Phi.Syntax.Abs.AttributeSugar
instance Prettyprinter.Internal.Pretty [Language.EO.Phi.Syntax.Abs.Binding]
instance Prettyprinter.Internal.Pretty Language.EO.Phi.Syntax.Abs.Attribute
instance Prettyprinter.Internal.Pretty [Language.EO.Phi.Syntax.Abs.LabelId]
instance Prettyprinter.Internal.Pretty Language.EO.Phi.Syntax.Abs.RuleAttribute
instance Prettyprinter.Internal.Pretty Language.EO.Phi.Syntax.Abs.PeeledObject
instance Prettyprinter.Internal.Pretty Language.EO.Phi.Syntax.Abs.ObjectHead
instance Prettyprinter.Internal.Pretty Language.EO.Phi.Syntax.Abs.ObjectAction
instance Prettyprinter.Internal.Pretty [Language.EO.Phi.Syntax.Abs.ObjectAction]

module Language.EO.Phi.Preprocess
symbol :: String -> Parser String
lexeme :: Parser a -> Parser a
type Parser = Parsec Void String
parseTail :: Parser String
parseLabelId :: Parser LabelId
parseToken :: String -> (String -> a) -> Parser a
parseObjectMetaId :: Parser ObjectMetaId
parseBytesMetaId :: Parser BytesMetaId
parseLabelMetaId :: Parser LabelMetaId
parseMetaId :: Parser MetaId
parseAlphaIndex :: Parser AlphaIndex
parseAttribute :: Parser Attribute
parseBindingArrow :: Parser ()
parseAttributeSugar :: Parser AttributeSugar
type Attr = Either MetaId AttributeSugar
parseAlphaBindingSugar :: Parser Attr
splitInput :: Parser a -> String -> [Either String (Tokens [Char], a)]
addPrefix :: Parser Attr -> String -> [String]
preprocess' :: Parser Attr -> String -> String
preprocess :: String -> String
input1 :: String

module Language.EO.Phi.Syntax.Lex
alex_tab_size :: Int
alex_base :: AlexAddr
alex_table :: AlexAddr
alex_check :: AlexAddr
alex_deflt :: AlexAddr
alex_accept :: Array Int (AlexAcc user)
alex_actions :: Array Int (Posn -> String -> Token)
alex_action_3 :: Posn -> String -> Token
alex_action_4 :: Posn -> String -> Token
alex_action_5 :: Posn -> String -> Token
alex_action_6 :: Posn -> String -> Token
alex_action_7 :: Posn -> String -> Token
alex_action_8 :: Posn -> String -> Token
alex_action_9 :: Posn -> String -> Token
alex_action_10 :: Posn -> String -> Token
alex_action_11 :: Posn -> String -> Token
alex_action_12 :: Posn -> String -> Token
alex_action_13 :: Posn -> String -> Token
alex_action_14 :: Posn -> String -> Token
alex_action_15 :: Posn -> String -> Token
alex_action_16 :: Posn -> String -> Token
alex_action_17 :: Posn -> String -> Token
alex_action_18 :: Posn -> String -> Token
alex_action_19 :: Posn -> String -> Token
alex_action_20 :: Posn -> String -> Token
data AlexAddr
AlexA# :: Addr# -> AlexAddr
alexIndexInt16OffAddr :: AlexAddr -> Int# -> Int#
alexIndexInt32OffAddr :: AlexAddr -> Int# -> Int#
quickIndex :: Array Int (AlexAcc (Any :: Type)) -> Int -> AlexAcc (Any :: Type)
data AlexReturn a
AlexEOF :: AlexReturn a
AlexError :: !AlexInput -> AlexReturn a
AlexSkip :: !AlexInput -> !Int -> AlexReturn a
AlexToken :: !AlexInput -> !Int -> a -> AlexReturn a
alexScan :: (Posn, Char, [Byte], String) -> Int -> AlexReturn (Posn -> String -> Token)
alexScanUser :: t -> (Posn, Char, [Byte], String) -> Int -> AlexReturn (Posn -> String -> Token)
alex_scan_tkn :: t -> t -> Int# -> AlexInput -> Int# -> AlexLastAcc -> (AlexLastAcc, (Posn, Char, [Byte], String))
data AlexLastAcc
AlexNone :: AlexLastAcc
AlexLastAcc :: !Int -> !AlexInput -> !Int -> AlexLastAcc
AlexLastSkip :: !AlexInput -> !Int -> AlexLastAcc
data AlexAcc user
AlexAccNone :: AlexAcc user
AlexAcc :: Int -> AlexAcc user
AlexAccSkip :: AlexAcc user

-- | Create a token with position.
tok :: (String -> Tok) -> Posn -> String -> Token

-- | Token without position.
data Tok

-- | Reserved word or symbol.
TK :: {-# UNPACK #-} !TokSymbol -> Tok

-- | String literal.
TL :: !String -> Tok

-- | Integer literal.
TI :: !String -> Tok

-- | Identifier.
TV :: !String -> Tok

-- | Float literal.
TD :: !String -> Tok

-- | Character literal.
TC :: !String -> Tok
T_Bytes :: !String -> Tok
T_Function :: !String -> Tok
T_LabelId :: !String -> Tok
T_AlphaIndex :: !String -> Tok
T_LabelMetaId :: !String -> Tok
T_TailMetaId :: !String -> Tok
T_BindingsMetaId :: !String -> Tok
T_ObjectMetaId :: !String -> Tok
T_BytesMetaId :: !String -> Tok
T_MetaFunctionName :: !String -> Tok
T_IntegerSigned :: !String -> Tok
T_DoubleSigned :: !String -> Tok
T_StringRaw :: !String -> Tok

-- | Smart constructor for <a>Tok</a> for the sake of backwards
--   compatibility.
pattern TS :: String -> Int -> Tok

-- | Keyword or symbol tokens have a unique ID.
data TokSymbol
TokSymbol :: String -> !Int -> TokSymbol

-- | Keyword or symbol text.
[tsText] :: TokSymbol -> String

-- | Unique ID.
[tsID] :: TokSymbol -> !Int

-- | Token with position.
data Token
PT :: Posn -> Tok -> Token
Err :: Posn -> Token

-- | Pretty print a position.
printPosn :: Posn -> String

-- | Pretty print the position of the first token in the list.
tokenPos :: [Token] -> String

-- | Get the position of a token.
tokenPosn :: Token -> Posn

-- | Get line and column of a token.
tokenLineCol :: Token -> (Int, Int)

-- | Get line and column of a position.
posLineCol :: Posn -> (Int, Int)

-- | Convert a token into "position token" form.
mkPosToken :: Token -> ((Int, Int), String)

-- | Convert a token to its text.
tokenText :: Token -> String

-- | Convert a token to a string.
prToken :: Token -> String

-- | Finite map from text to token organized as binary search tree.
data BTree

-- | Nil (leaf).
N :: BTree

-- | Binary node.
B :: String -> Tok -> BTree -> BTree -> BTree

-- | Convert potential keyword into token or use fallback conversion.
eitherResIdent :: (String -> Tok) -> String -> Tok

-- | The keywords and symbols of the language organized as binary search
--   tree.
resWords :: BTree

-- | Unquote string literal.
unescapeInitTail :: String -> String
data Posn
Pn :: !Int -> !Int -> !Int -> Posn
alexStartPos :: Posn
alexMove :: Posn -> Char -> Posn
type Byte = Word8
type AlexInput = (Posn, Char, [Byte], String)
tokens :: String -> [Token]
alexGetByte :: AlexInput -> Maybe (Byte, AlexInput)
alexInputPrevChar :: AlexInput -> Char

-- | Encode a Haskell String to a list of Word8 values, in UTF8 format.
utf8Encode :: Char -> [Word8]
instance GHC.Show.Show Language.EO.Phi.Syntax.Lex.TokSymbol
instance GHC.Classes.Ord Language.EO.Phi.Syntax.Lex.Tok
instance GHC.Show.Show Language.EO.Phi.Syntax.Lex.Tok
instance GHC.Classes.Eq Language.EO.Phi.Syntax.Lex.Tok
instance GHC.Show.Show Language.EO.Phi.Syntax.Lex.BTree
instance GHC.Classes.Ord Language.EO.Phi.Syntax.Lex.Posn
instance GHC.Show.Show Language.EO.Phi.Syntax.Lex.Posn
instance GHC.Classes.Eq Language.EO.Phi.Syntax.Lex.Posn
instance GHC.Classes.Ord Language.EO.Phi.Syntax.Lex.Token
instance GHC.Show.Show Language.EO.Phi.Syntax.Lex.Token
instance GHC.Classes.Eq Language.EO.Phi.Syntax.Lex.Token
instance GHC.Classes.Eq Language.EO.Phi.Syntax.Lex.TokSymbol
instance GHC.Classes.Ord Language.EO.Phi.Syntax.Lex.TokSymbol

module Language.EO.Phi.Syntax.Par
happyError :: [Token] -> Err a
myLexer :: String -> [Token]
pProgram :: [Token] -> Err Program
pMetaId :: [Token] -> Err MetaId
pObject :: [Token] -> Err Object
pBinding :: [Token] -> Err Binding
pListBinding :: [Token] -> Err [Binding]
pAttributeSugar :: [Token] -> Err AttributeSugar
pListAttribute :: [Token] -> Err [Attribute]
pAttribute :: [Token] -> Err Attribute
pRuleAttribute :: [Token] -> Err RuleAttribute
pPeeledObject :: [Token] -> Err PeeledObject
pObjectHead :: [Token] -> Err ObjectHead
pObjectAction :: [Token] -> Err ObjectAction
pListObjectAction :: [Token] -> Err [ObjectAction]

module Language.EO.Phi.Syntax
desugar :: Object -> Object

-- | The top-level printing method.
printTree :: (Pretty a, SugarableFinally a) => a -> String
printTreeDontSugar :: Pretty a => a -> String

-- | Convert an <a>Int</a> into <a>Bytes</a> representation.
--   
--   <pre>
--   &gt;&gt;&gt; intToBytes 7
--   Bytes "00-00-00-00-00-00-00-07"
--   
--   &gt;&gt;&gt; intToBytes (3^33)
--   Bytes "00-13-BF-EF-A6-5A-BB-83"
--   
--   &gt;&gt;&gt; intToBytes (-1)
--   Bytes "FF-FF-FF-FF-FF-FF-FF-FF"
--   </pre>
intToBytes :: Int -> Bytes

-- | Convert an <a>Int64</a> into <a>Bytes</a> representation.
--   
--   <pre>
--   &gt;&gt;&gt; int64ToBytes 7
--   Bytes "00-00-00-00-00-00-00-07"
--   
--   &gt;&gt;&gt; int64ToBytes (3^33)
--   Bytes "00-13-BF-EF-A6-5A-BB-83"
--   
--   &gt;&gt;&gt; int64ToBytes (-1)
--   Bytes "FF-FF-FF-FF-FF-FF-FF-FF"
--   </pre>
int64ToBytes :: Int64 -> Bytes

-- | Convert an <a>Int32</a> into <a>Bytes</a> representation.
--   
--   <pre>
--   &gt;&gt;&gt; int32ToBytes 7
--   Bytes "00-00-00-07"
--   
--   &gt;&gt;&gt; int32ToBytes (3^33)
--   Bytes "A6-5A-BB-83"
--   
--   &gt;&gt;&gt; int32ToBytes (-1)
--   Bytes "FF-FF-FF-FF"
--   </pre>
int32ToBytes :: Int32 -> Bytes

-- | Convert an <a>Int16</a> into <a>Bytes</a> representation.
--   
--   <pre>
--   &gt;&gt;&gt; int16ToBytes 7
--   Bytes "00-07"
--   
--   &gt;&gt;&gt; int16ToBytes (3^33)
--   Bytes "BB-83"
--   
--   &gt;&gt;&gt; int16ToBytes (-1)
--   Bytes "FF-FF"
--   </pre>
int16ToBytes :: Int16 -> Bytes

-- | Encode <a>Double</a> as <a>Bytes</a> following IEEE754.
--   
--   Note: it is called "float" in EO, but it actually occupies 8 bytes so
--   it corresponds to <a>Double</a>.
--   
--   <pre>
--   &gt;&gt;&gt; floatToBytes 0
--   Bytes "00-00-00-00-00-00-00-00"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; floatToBytes (-0.1)
--   Bytes "BF-B9-99-99-99-99-99-9A"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; floatToBytes (1/0)       -- Infinity
--   Bytes "7F-F0-00-00-00-00-00-00"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; floatToBytes (asin 2) `elem` ["FF-F8-00-00-00-00-00-00", "7F-F8-00-00-00-00-00-00"]  -- sNaN or qNaN
--   True
--   </pre>
floatToBytes :: Double -> Bytes

-- | Convert <a>Bool</a> to <a>Bytes</a>.
--   
--   <pre>
--   &gt;&gt;&gt; boolToBytes False
--   Bytes "00-"
--   
--   &gt;&gt;&gt; boolToBytes True
--   Bytes "01-"
--   </pre>
boolToBytes :: Bool -> Bytes

-- | Encode <a>String</a> as <a>Bytes</a>.
--   
--   <pre>
--   &gt;&gt;&gt; stringToBytes "Hello, world!"
--   Bytes "48-65-6C-6C-6F-2C-20-77-6F-72-6C-64-21"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stringToBytes "–ü—Ä–∏–≤–µ—Ç, –º–∏—Ä!"
--   Bytes "D0-9F-D1-80-D0-B8-D0-B2-D0-B5-D1-82-2C-20-D0-BC-D0-B8-D1-80-21"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stringToBytes  "hello, Â§ßÂÆ∂!"
--   Bytes "68-65-6C-6C-6F-2C-20-E5-A4-A7-E5-AE-B6-21"
--   </pre>
stringToBytes :: String -> Bytes

-- | Parse <a>Bytes</a> as <a>Int</a>.
--   
--   <pre>
--   &gt;&gt;&gt; bytesToInt "00-13-BF-EF-A6-5A-BB-83"
--   5559060566555523
--   
--   &gt;&gt;&gt; bytesToInt "AB-"
--   171
--   </pre>
--   
--   May error on invalid <a>Bytes</a>:
--   
--   <pre>
--   &gt;&gt;&gt; bytesToInt "s"
--   *** Exception: Prelude.head: empty list
--   ...
--   ...
--   ...
--   ...
--   ...
--   ...
--   </pre>
bytesToInt :: Bytes -> Int

-- | Parse <a>Bytes</a> as <a>Int64</a>.
--   
--   <pre>
--   &gt;&gt;&gt; bytesToInt64 "00-13-BF-EF-A6-5A-BB-83"
--   5559060566555523
--   
--   &gt;&gt;&gt; bytesToInt64 "AB-"
--   171
--   </pre>
--   
--   May error on invalid <a>Bytes</a>:
--   
--   <pre>
--   &gt;&gt;&gt; bytesToInt64 "s"
--   *** Exception: Prelude.head: empty list
--   ...
--   ...
--   ...
--   ...
--   ...
--   ...
--   </pre>
bytesToInt64 :: Bytes -> Int64

-- | Parse <a>Bytes</a> as <a>Int32</a>.
--   
--   <pre>
--   &gt;&gt;&gt; bytesToInt32 "A6-5A-BB-83"
--   -1504003197
--   
--   &gt;&gt;&gt; bytesToInt32 "AB-"
--   171
--   </pre>
--   
--   May error on invalid <a>Bytes</a>:
--   
--   <pre>
--   &gt;&gt;&gt; bytesToInt32 "s"
--   *** Exception: Prelude.head: empty list
--   ...
--   ...
--   ...
--   ...
--   ...
--   ...
--   </pre>
bytesToInt32 :: Bytes -> Int32

-- | Parse <a>Bytes</a> as <a>Int16</a>.
--   
--   <pre>
--   &gt;&gt;&gt; bytesToInt16 "BB-83"
--   -17533
--   
--   &gt;&gt;&gt; bytesToInt16 "AB-"
--   171
--   </pre>
--   
--   May error on invalid <a>Bytes</a>:
--   
--   <pre>
--   &gt;&gt;&gt; bytesToInt16 "s"
--   *** Exception: Prelude.head: empty list
--   ...
--   ...
--   ...
--   ...
--   ...
--   ...
--   </pre>
bytesToInt16 :: Bytes -> Int16

-- | Decode <a>Double</a> from <a>Bytes</a> following IEEE754.
--   
--   <pre>
--   &gt;&gt;&gt; bytesToFloat "00-00-00-00-00-00-00-00"
--   0.0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bytesToFloat "BF-B9-99-99-99-99-99-9A"
--   -0.1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bytesToFloat "7F-F0-00-00-00-00-00-00"
--   Infinity
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bytesToFloat "FF-F8-00-00-00-00-00-00"
--   NaN
--   </pre>
bytesToFloat :: Bytes -> Double

-- | Decode <a>String</a> from <a>Bytes</a>.
--   
--   <pre>
--   &gt;&gt;&gt; bytesToString "48-65-6C-6C-6F-2C-20-77-6F-72-6C-64-21"
--   "Hello, world!"
--   </pre>
bytesToString :: Bytes -> String

-- | Interpret <a>Bytes</a> as <a>Bool</a>.
--   
--   Zero is interpreted as <a>False</a>.
--   
--   <pre>
--   &gt;&gt;&gt; bytesToBool "00-"
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bytesToBool "00-00"
--   False
--   </pre>
--   
--   Everything else is interpreted as <a>True</a>.
--   
--   <pre>
--   &gt;&gt;&gt; bytesToBool "01-"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bytesToBool "00-01"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bytesToBool "AB-CD"
--   True
--   </pre>
bytesToBool :: Bytes -> Bool
wrapBytesInConstInt :: Bytes -> Object
wrapBytesInConstInt64 :: Bytes -> Object
wrapBytesInConstInt32 :: Bytes -> Object
wrapBytesInConstInt16 :: Bytes -> Object
wrapBytesInConstFloat :: Bytes -> Object
wrapBytesInConstString :: Bytes -> Object
wrapBytesInBytes :: Bytes -> Object
wrapBytesInInt :: Bytes -> Object
wrapBytesInFloat :: Bytes -> Object
wrapBytesAsBool :: Bytes -> Object
wrapBytesInString :: Bytes -> Object
wrapTermination :: Object

-- | Select a slice (section) of <a>Bytes</a>.
--   
--   <pre>
--   &gt;&gt;&gt; sliceBytes "12-34-56" 1 1
--   Bytes "34-"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sliceBytes "12-34-56" 1 0
--   Bytes "00-"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sliceBytes "12-34-56" 0 2
--   Bytes "12-34"
--   </pre>
sliceBytes :: Bytes -> Int -> Int -> Bytes

-- | Concatenate <a>Bytes</a>. FIXME: we should really use
--   <a>ByteString</a> instead of the underlying <a>String</a>
--   representation.
--   
--   <pre>
--   &gt;&gt;&gt; concatBytes "00-" "01-02"
--   Bytes "00-01-02"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; concatBytes "03-04" "01-02"
--   Bytes "03-04-01-02"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; concatBytes "03-04" "01-"
--   Bytes "03-04-01"
--   </pre>
concatBytes :: Bytes -> Bytes -> Bytes

-- | Split a list into chunks of given size. All lists in the result are
--   guaranteed to have length less than or equal to the given size.
--   
--   <pre>
--   &gt;&gt;&gt; chunksOf 2 "012345678"
--   ["01","23","45","67","8"]
--   </pre>
--   
--   See <a>paddedLeftChunksOf</a> for a version with padding to guarantee
--   exact chunk size.
chunksOf :: Int -> [a] -> [[a]]

-- | Split a list into chunks of given size, padding on the left if
--   necessary. All lists in the result are guaranteed to have given size.
--   
--   <pre>
--   &gt;&gt;&gt; paddedLeftChunksOf '0' 2 "1234567"
--   ["01","23","45","67"]
--   
--   &gt;&gt;&gt; paddedLeftChunksOf '0' 2 "123456"
--   ["12","34","56"]
--   </pre>
--   
--   <pre>
--   n &gt; 0  ==&gt;  all (\chunk -&gt; length chunk == n) (paddedLeftChunksOf c n s)
--   </pre>
paddedLeftChunksOf :: a -> Int -> [a] -> [[a]]

-- | Normalize the bytestring representation to fit valid <a>Bytes</a>
--   token.
--   
--   <pre>
--   &gt;&gt;&gt; normalizeBytes "238714ABCDEF"
--   "23-87-14-AB-CD-EF"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; normalizeBytes "0238714ABCDEF"
--   "00-23-87-14-AB-CD-EF"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; normalizeBytes "4"
--   "04-"
--   </pre>
normalizeBytes :: String -> String
parseWith :: (DesugarableInitially a, CheckableSyntaxInitially a) => ([Token] -> Either String a) -> String -> Either String a
errorExpectedDesugaredObject :: Object -> a
errorExpectedDesugaredBinding :: Binding -> a
errorExpectedDesugaredAttribute :: Attribute -> a
class SugarableFinally a
sugarFinally :: SugarableFinally a => a -> a
pattern AlphaBinding' :: Attribute -> Object -> Binding
pattern AlphaBinding'' :: LabelId -> [Attribute] -> Object -> Binding
instance Language.EO.Phi.Syntax.SugarableFinally Language.EO.Phi.Syntax.Abs.Object
instance Language.EO.Phi.Syntax.SugarableFinally Language.EO.Phi.Syntax.ApplicationBindings
instance Language.EO.Phi.Syntax.SugarableFinally Language.EO.Phi.Syntax.Abs.Program
instance Language.EO.Phi.Syntax.SugarableFinally a => Language.EO.Phi.Syntax.SugarableFinally [a]
instance Language.EO.Phi.Syntax.SugarableFinally Language.EO.Phi.Syntax.Abs.Binding
instance Language.EO.Phi.Syntax.SugarableFinally Language.EO.Phi.Syntax.Abs.ObjectMetaId
instance Language.EO.Phi.Syntax.SugarableFinally Language.EO.Phi.Syntax.Abs.BindingsMetaId
instance Language.EO.Phi.Syntax.SugarableFinally Language.EO.Phi.Syntax.Abs.LabelMetaId
instance Language.EO.Phi.Syntax.SugarableFinally Language.EO.Phi.Syntax.Abs.BytesMetaId
instance Language.EO.Phi.Syntax.SugarableFinally Language.EO.Phi.Syntax.Abs.Attribute
instance Language.EO.Phi.Syntax.SugarableFinally Language.EO.Phi.Syntax.Abs.TailMetaId
instance Language.EO.Phi.Syntax.SugarableFinally Language.EO.Phi.Syntax.Abs.Bytes
instance Language.EO.Phi.Syntax.SugarableFinally Language.EO.Phi.Syntax.Abs.MetaId
instance Language.EO.Phi.Syntax.CheckableSyntaxInitially Language.EO.Phi.Syntax.Abs.Program
instance Language.EO.Phi.Syntax.CheckableSyntaxInitially Language.EO.Phi.Syntax.Abs.Binding
instance Language.EO.Phi.Syntax.CheckableSyntaxInitially Language.EO.Phi.Syntax.Abs.Object
instance Language.EO.Phi.Syntax.CheckableSyntaxInitially Language.EO.Phi.Syntax.Abs.Attribute
instance Language.EO.Phi.Syntax.CheckableSyntaxInitially Language.EO.Phi.Syntax.Abs.AttributeSugar
instance Language.EO.Phi.Syntax.CheckableSyntaxInitially Language.EO.Phi.Syntax.Abs.RuleAttribute
instance Language.EO.Phi.Syntax.CheckableSyntaxInitially Language.EO.Phi.Syntax.Abs.PeeledObject
instance Language.EO.Phi.Syntax.CheckableSyntaxInitially Language.EO.Phi.Syntax.Abs.ObjectHead
instance Language.EO.Phi.Syntax.CheckableSyntaxInitially Language.EO.Phi.Syntax.Abs.MetaId
instance Language.EO.Phi.Syntax.DesugarableInitially Language.EO.Phi.Syntax.Abs.Object
instance Language.EO.Phi.Syntax.DesugarableInitially [Language.EO.Phi.Syntax.Abs.Binding]
instance Language.EO.Phi.Syntax.DesugarableInitially Language.EO.Phi.Syntax.Abs.Program
instance Language.EO.Phi.Syntax.DesugarableInitially Language.EO.Phi.Syntax.Abs.Binding
instance Language.EO.Phi.Syntax.DesugarableInitially Language.EO.Phi.Syntax.Abs.AttributeSugar
instance Language.EO.Phi.Syntax.DesugarableInitially Language.EO.Phi.Syntax.Abs.Attribute
instance Language.EO.Phi.Syntax.DesugarableInitially Language.EO.Phi.Syntax.Abs.RuleAttribute
instance Language.EO.Phi.Syntax.DesugarableInitially Language.EO.Phi.Syntax.Abs.PeeledObject
instance Language.EO.Phi.Syntax.DesugarableInitially Language.EO.Phi.Syntax.Abs.ObjectHead
instance Language.EO.Phi.Syntax.DesugarableInitially Language.EO.Phi.Syntax.Abs.MetaId
instance Data.String.IsString Language.EO.Phi.Syntax.Abs.Program
instance Data.String.IsString Language.EO.Phi.Syntax.Abs.Object
instance Data.String.IsString Language.EO.Phi.Syntax.Abs.Binding
instance Data.String.IsString Language.EO.Phi.Syntax.Abs.Attribute
instance Data.String.IsString Language.EO.Phi.Syntax.Abs.AttributeSugar
instance Data.String.IsString Language.EO.Phi.Syntax.Abs.RuleAttribute
instance Data.String.IsString Language.EO.Phi.Syntax.Abs.PeeledObject
instance Data.String.IsString Language.EO.Phi.Syntax.Abs.ObjectHead
instance Data.String.IsString Language.EO.Phi.Syntax.Abs.MetaId

module Language.EO.Phi.Rules.Common

-- | State of evaluation is not needed yet, but it might be in the future
type EvaluationState = ()
type NamedRule = (String, Rule)
type Atoms = HashMap String (String -> Object -> EvaluationState -> DataizeChain (Object, EvaluationState))
data Context
Context :: Bool -> [NamedRule] -> Atoms -> Atoms -> NonEmpty Object -> Attribute -> Bool -> Bool -> Bool -> Bool -> Bool -> Context
[builtinRules] :: Context -> Bool
[allRules] :: Context -> [NamedRule]
[enabledAtoms] :: Context -> Atoms
[knownAtoms] :: Context -> Atoms
[outerFormations] :: Context -> NonEmpty Object
[currentAttr] :: Context -> Attribute

-- | Temporary hack for applying Ksi and Phi rules when dataizing
[insideFormation] :: Context -> Bool
[insideAbstractFormation] :: Context -> Bool

-- | Temporary flag to only dataize Package attributes for the top-level
--   formation.
[dataizePackage] :: Context -> Bool
[minimizeTerms] :: Context -> Bool
[insideSubObject] :: Context -> Bool
sameContext :: Context -> Context -> Bool

-- | A rule tries to apply a transformation to the root object, if
--   possible.
type Rule = Context -> Object -> [Object]
applyOneRuleAtRoot :: Context -> Object -> [(String, Object)]
extendContextWith :: Object -> Context -> Context
isEmptyBinding :: Binding -> Bool
withSubObject :: (Context -> Object -> [(String, Object)]) -> Context -> Object -> [(String, Object)]

-- | Given a unary function that operates only on plain objects, converts
--   it to a function that operates on named objects
propagateName1 :: (a -> b) -> (name, a) -> (name, b)

-- | Given a binary function that operates only on plain objects, converts
--   it to a function that operates on named objects
propagateName2 :: (a -> b -> c) -> (name, a) -> b -> (name, c)
withSubObjectBindings :: (Context -> Object -> [(String, Object)]) -> Context -> [Binding] -> [(String, [Binding])]
withSubObjectBinding :: (Context -> Object -> [(String, Object)]) -> Context -> Binding -> [(String, Binding)]
applyOneRule :: Context -> Object -> [(String, Object)]
isNF :: Context -> Object -> Bool

-- | Apply rules until we get a normal form.
applyRules :: Context -> Object -> [Object]
data ApplicationLimits
ApplicationLimits :: Int -> Int -> ApplicationLimits
[maxDepth] :: ApplicationLimits -> Int
[maxTermSize] :: ApplicationLimits -> Int
defaultApplicationLimits :: Int -> ApplicationLimits
objectSize :: Object -> Int
bindingSize :: Binding -> Int

-- | A variant of <a>applyRules</a> with a maximum application depth.
applyRulesWith :: ApplicationLimits -> Context -> Object -> [Object]
equalProgram :: Program -> Program -> Bool
equalObject :: Object -> Object -> Bool
equalObjectNamed :: (String, Object) -> (String, Object) -> Bool
equalBindings :: [Binding] -> [Binding] -> Bool
equalBinding :: Binding -> Binding -> Bool
data LogEntry log
LogEntry :: String -> log -> Int -> LogEntry log
[logEntryMessage] :: LogEntry log -> String
[logEntryLog] :: LogEntry log -> log
[logEntryLevel] :: LogEntry log -> Int
newtype Chain log result
Chain :: (Context -> [([LogEntry log], result)]) -> Chain log result
[runChain] :: Chain log result -> Context -> [([LogEntry log], result)]
type NormalizeChain = Chain Object
type DataizeChain = Chain (Either Object Bytes)
logStep :: String -> info -> Chain info ()
incLogLevel :: Chain info a -> Chain info a
choose :: [a] -> Chain log a
msplit :: Chain log a -> Chain log (Maybe (a, Chain log a))
transformLogs :: (log1 -> log2) -> Chain log1 a -> Chain log2 a
transformNormLogs :: NormalizeChain a -> DataizeChain a
listen :: Chain log a -> Chain log (a, [LogEntry log])
minimizeObject' :: DataizeChain (Either Object Bytes) -> DataizeChain (Either Object Bytes)
minimizeObject :: DataizeChain (Either Object Bytes) -> DataizeChain (Either Object Bytes)
smallestObject :: [Either Object bytes] -> Object -> Object
getContext :: Chain a Context
withContext :: Context -> Chain log a -> Chain log a
modifyContext :: (Context -> Context) -> Chain log a -> Chain log a
applyRulesChain' :: Context -> Object -> [([LogEntry Object], Object)]

-- | Apply the rules until the object is normalized, preserving the history
--   (chain) of applications.
applyRulesChain :: Object -> NormalizeChain Object
applyRulesChainWith' :: ApplicationLimits -> Context -> Object -> [([LogEntry Object], Object)]

-- | A variant of <a>applyRulesChain</a> with a maximum application depth.
applyRulesChainWith :: ApplicationLimits -> Object -> NormalizeChain Object

-- | Lookup a binding by the attribute name.
lookupBinding :: Attribute -> [Binding] -> Maybe Object
objectBindings :: Object -> [Binding]
isRhoBinding :: Binding -> Bool
hideRhoInBinding :: Binding -> Binding
hideRho :: Object -> Object
hideRhoInBinding1 :: Binding -> Binding
hideRho1 :: Object -> Object
instance GHC.Base.Functor Language.EO.Phi.Rules.Common.LogEntry
instance GHC.Show.Show log => GHC.Show.Show (Language.EO.Phi.Rules.Common.LogEntry log)
instance GHC.Base.Functor (Language.EO.Phi.Rules.Common.Chain log)
instance GHC.Base.Applicative (Language.EO.Phi.Rules.Common.Chain a)
instance GHC.Base.Monad (Language.EO.Phi.Rules.Common.Chain a)
instance Control.Monad.Fail.MonadFail (Language.EO.Phi.Rules.Common.Chain a)

module Language.EO.Phi.Rules.Yaml
data RuleSet
RuleSet :: String -> [Rule] -> RuleSet
[$sel:title:RuleSet] :: RuleSet -> String
[$sel:rules:RuleSet] :: RuleSet -> [Rule]
data RuleContext
RuleContext :: Maybe Object -> Maybe Object -> Maybe Attribute -> RuleContext
[$sel:global_object:RuleContext] :: RuleContext -> Maybe Object
[$sel:current_object:RuleContext] :: RuleContext -> Maybe Object
[$sel:current_attribute:RuleContext] :: RuleContext -> Maybe Attribute
data Rule
Rule :: String -> String -> Maybe RuleContext -> Maybe [MetaId] -> Object -> Object -> Maybe [FreshMetaId] -> Maybe [Condition] -> Maybe [RuleTest] -> Rule
[$sel:name:Rule] :: Rule -> String
[$sel:description:Rule] :: Rule -> String
[$sel:context:Rule] :: Rule -> Maybe RuleContext
[$sel:forall:Rule] :: Rule -> Maybe [MetaId]
[$sel:pattern:Rule] :: Rule -> Object
[$sel:result:Rule] :: Rule -> Object
[$sel:fresh:Rule] :: Rule -> Maybe [FreshMetaId]
[$sel:when:Rule] :: Rule -> Maybe [Condition]
[$sel:tests:Rule] :: Rule -> Maybe [RuleTest]
data FreshMetaId
FreshMetaId :: LabelMetaId -> Maybe String -> FreshMetaId
[$sel:name:FreshMetaId] :: FreshMetaId -> LabelMetaId
[$sel:prefix:FreshMetaId] :: FreshMetaId -> Maybe String
data RuleTest
RuleTest :: String -> Object -> [Object] -> Maybe [RuleTestOption] -> RuleTest
[$sel:name:RuleTest] :: RuleTest -> String
[$sel:input:RuleTest] :: RuleTest -> Object
[$sel:output:RuleTest] :: RuleTest -> [Object]
[$sel:options:RuleTest] :: RuleTest -> Maybe [RuleTestOption]
newtype RuleTestOption
TakeOne :: Bool -> RuleTestOption
[$sel:take_one:TakeOne] :: RuleTestOption -> Bool
data AttrsInBindings
AttrsInBindings :: [RuleAttribute] -> [Binding] -> AttrsInBindings
[$sel:attrs:AttrsInBindings] :: AttrsInBindings -> [RuleAttribute]
[$sel:bindings:AttrsInBindings] :: AttrsInBindings -> [Binding]
data Condition
IsNF :: Object -> Condition
[$sel:nf:IsNF] :: Condition -> Object
IsNFInsideFormation :: Object -> Condition
[$sel:nf_inside_formation:IsNF] :: Condition -> Object
PresentAttrs :: AttrsInBindings -> Condition
[$sel:present_attrs:IsNF] :: Condition -> AttrsInBindings
AbsentAttrs :: AttrsInBindings -> Condition
[$sel:absent_attrs:IsNF] :: Condition -> AttrsInBindings
AttrNotEqual :: (Attribute, Attribute) -> Condition
[$sel:not_equal:IsNF] :: Condition -> (Attribute, Attribute)
ApplyInSubformations :: Bool -> Condition
[$sel:apply_in_subformations:IsNF] :: Condition -> Bool
ApplyInAbstractSubformations :: Bool -> Condition
[$sel:apply_in_abstract_subformations:IsNF] :: Condition -> Bool
parseRuleSetFromFile :: FilePath -> IO RuleSet
convertRule :: Rule -> Rule
convertRuleNamed :: Rule -> NamedRule
mkFreshSubst :: Context -> Object -> Maybe [FreshMetaId] -> Subst
mkFreshAttributes :: Set LabelId -> [FreshMetaId] -> [(LabelMetaId, Attribute)]
mkFreshAttribute :: Set LabelId -> FreshMetaId -> ((LabelMetaId, Attribute), Set LabelId)
usedLabelIds :: Context -> Set LabelId
objectLabelIds :: Object -> Set LabelId
bindingLabelIds :: Binding -> Set LabelId
attrLabelIds :: Attribute -> Set LabelId
matchContext :: Context -> Maybe RuleContext -> [Subst]
objectMetaIds :: Object -> Set MetaId
bindingMetaIds :: Binding -> Set MetaId
attrMetaIds :: Attribute -> Set MetaId
objectHasMetavars :: Object -> Bool
bindingHasMetavars :: Binding -> Bool
attrHasMetavars :: Attribute -> Bool

-- | Given a condition, and a substition from object matching tells whether
--   the condition matches the object
checkCond :: Context -> Condition -> Subst -> Bool
hasAttr :: RuleAttribute -> [Binding] -> Bool
data OneHoleContext
OneHoleContext :: !ObjectMetaId -> !Object -> OneHoleContext
[$sel:holeMetaId:OneHoleContext] :: OneHoleContext -> !ObjectMetaId
[$sel:contextObject:OneHoleContext] :: OneHoleContext -> !Object
data Subst
Subst :: [(ObjectMetaId, Object)] -> [(BindingsMetaId, [Binding])] -> [(LabelMetaId, Attribute)] -> [(BytesMetaId, Bytes)] -> [(TailMetaId, OneHoleContext)] -> Subst
[$sel:objectMetas:Subst] :: Subst -> [(ObjectMetaId, Object)]
[$sel:bindingsMetas:Subst] :: Subst -> [(BindingsMetaId, [Binding])]
[$sel:attributeMetas:Subst] :: Subst -> [(LabelMetaId, Attribute)]
[$sel:bytesMetas:Subst] :: Subst -> [(BytesMetaId, Bytes)]
[$sel:contextMetas:Subst] :: Subst -> [(TailMetaId, OneHoleContext)]
emptySubst :: Subst
applySubst :: Subst -> Object -> Object
applySubstAttr :: Subst -> Attribute -> Attribute
applySubstBindings :: Subst -> [Binding] -> [Binding]
applySubstBinding :: Subst -> Binding -> [Binding]
mergeSubst :: Subst -> Subst -> Subst
matchObject :: Object -> Object -> [Subst]
matchOneHoleContext :: TailMetaId -> Object -> Object -> [(Subst, OneHoleContext)]

-- | Evaluate meta functions given top-level context as an object and an
--   object
evaluateMetaFuncs :: Object -> Object -> Object
data MetaState
MetaState :: MetaState
evaluateMetaFuncs' :: Object -> State MetaState Object
evaluateMetaFuncsBinding :: Binding -> State MetaState Binding
matchBindings :: [Binding] -> [Binding] -> [Subst]
select :: [a] -> [(a, [a])]
matchFindBinding :: Binding -> [Binding] -> [([Binding], Subst)]
matchBinding :: Binding -> Binding -> [Subst]
matchAttr :: Attribute -> Attribute -> [Subst]
substThis :: Object -> Object -> Object
substThisBinding :: Object -> Binding -> Binding
contextualize :: Object -> Object -> Object
contextualizeBinding :: Object -> Binding -> Binding
instance GHC.Show.Show Language.EO.Phi.Rules.Yaml.RuleContext
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Rules.Yaml.RuleContext
instance GHC.Generics.Generic Language.EO.Phi.Rules.Yaml.RuleContext
instance GHC.Show.Show Language.EO.Phi.Rules.Yaml.FreshMetaId
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Rules.Yaml.FreshMetaId
instance GHC.Generics.Generic Language.EO.Phi.Rules.Yaml.FreshMetaId
instance GHC.Show.Show Language.EO.Phi.Rules.Yaml.RuleTestOption
instance GHC.Generics.Generic Language.EO.Phi.Rules.Yaml.RuleTestOption
instance GHC.Classes.Eq Language.EO.Phi.Rules.Yaml.RuleTestOption
instance GHC.Show.Show Language.EO.Phi.Rules.Yaml.RuleTest
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Rules.Yaml.RuleTest
instance GHC.Generics.Generic Language.EO.Phi.Rules.Yaml.RuleTest
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Rules.Yaml.AttrsInBindings
instance GHC.Show.Show Language.EO.Phi.Rules.Yaml.AttrsInBindings
instance GHC.Generics.Generic Language.EO.Phi.Rules.Yaml.AttrsInBindings
instance GHC.Show.Show Language.EO.Phi.Rules.Yaml.Condition
instance GHC.Generics.Generic Language.EO.Phi.Rules.Yaml.Condition
instance GHC.Show.Show Language.EO.Phi.Rules.Yaml.Rule
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Rules.Yaml.Rule
instance GHC.Generics.Generic Language.EO.Phi.Rules.Yaml.Rule
instance GHC.Show.Show Language.EO.Phi.Rules.Yaml.RuleSet
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Rules.Yaml.RuleSet
instance GHC.Generics.Generic Language.EO.Phi.Rules.Yaml.RuleSet
instance GHC.Show.Show Language.EO.Phi.Rules.Yaml.OneHoleContext
instance GHC.Generics.Generic Language.EO.Phi.Rules.Yaml.MetaState
instance GHC.Show.Show Language.EO.Phi.Rules.Yaml.Subst
instance GHC.Base.Semigroup Language.EO.Phi.Rules.Yaml.Subst
instance GHC.Base.Monoid Language.EO.Phi.Rules.Yaml.Subst
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Rules.Yaml.Condition
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Rules.Yaml.RuleTestOption
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Syntax.Abs.Object
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Syntax.Abs.Binding
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Syntax.Abs.ObjectMetaId
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Syntax.Abs.LabelMetaId
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Syntax.Abs.TailMetaId
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Syntax.Abs.BindingsMetaId
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Syntax.Abs.BytesMetaId
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Syntax.Abs.MetaId
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Syntax.Abs.Attribute
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Syntax.Abs.RuleAttribute
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Syntax.Abs.LabelId
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Syntax.Abs.AlphaIndex

module Language.EO.Phi.Rules.Fast
withBinding :: (Context -> Object -> Object) -> Context -> Binding -> Binding
isLambdaBinding :: Binding -> Bool
withSubObjects :: (Context -> Object -> Object) -> Context -> Object -> Object

-- | Normalize an object, following a version of call-by-value strategy:
--   
--   <ol>
--   <li>Apply rules in subobjects/subterms before applying a rule at
--   root.</li>
--   <li>Do not apply rules under formations with at least one void (empty)
--   binding.</li>
--   </ol>
--   
--   <pre>
--   runWithYegorRules applyRulesInsideOut "‚ü¶ x ‚Ü¶ ‚ü¶‚üß, y ‚Ü¶ ‚ü¶ z ‚Ü¶ ‚ü¶ w ‚Ü¶ Œæ.œÅ.œÅ.x ‚üß ‚üß ‚üß.y.z.w"
--   </pre>
--   
--   ‚ü¶ œÅ ‚Ü¶ ‚ü¶ œÅ ‚Ü¶ ‚ü¶ ‚üß ‚üß ‚üß
applyRulesInsideOut :: Context -> Object -> Object
fastYegorInsideOutAsRule :: NamedRule
fastYegorInsideOutBinding :: Context -> Binding -> Binding
fastYegorInsideOut :: Context -> Object -> Object

module Language.EO.Phi.Normalize
normalizeObject :: Object -> State Context Object

-- | Normalize an input ùúë-program.
normalize :: Program -> Program

-- | Split compound object into its head and applications/dispatch actions.
peelObject :: Object -> PeeledObject
unpeelObject :: PeeledObject -> Object
instance GHC.Generics.Generic Language.EO.Phi.Normalize.Context

module Language.EO.Phi.Dataize
desugarAsBytes :: Either Object Bytes -> Either Object Bytes
pattern AsBytes :: Bytes -> Either Object Bytes
pattern AsObject :: Object -> Either Object Bytes

-- | Perform one step of dataization to the object (if possible).
dataizeStep :: Context -> Object -> (Context, Either Object Bytes)
dataizeStep' :: Context -> Object -> Either Object Bytes

-- | Recursively perform normalization and dataization until we get bytes
--   in the end.
dataizeRecursively :: Context -> Object -> Either Object Bytes
dataizeStepChain' :: Context -> Object -> ([LogEntry (Either Object Bytes)], Either Object Bytes)
data DataizeStepMode
DataizeOnlyLambda :: DataizeStepMode
DataizeAll :: DataizeStepMode

-- | Perform one step of dataization to the object (if possible), reporting
--   back individiual steps.
dataizeStepChain :: DataizeStepMode -> Object -> DataizeChain (Context, Either Object Bytes)
dataizeRecursivelyChain' :: Context -> Object -> ([LogEntry (Either Object Bytes)], Either Object Bytes)

-- | Recursively perform normalization and dataization until we get bytes
--   in the end, reporting intermediate steps
dataizeRecursivelyChain :: Bool -> Object -> DataizeChain (Either Object Bytes)

-- | Given converters between Bytes and some data type, a binary function
--   on this data type, an object, and the current state of evaluation,
--   returns the new object and a possibly modified state along with
--   intermediate steps.
evaluateDataizationFunChain :: (res -> Bytes) -> (Bytes -> a) -> (Bytes -> Object) -> (a -> a -> res) -> Object -> EvaluationState -> DataizeChain (Object, EvaluationState)
evaluateBinaryDataizationFunChain :: (res -> Bytes) -> (Bytes -> a) -> (Bytes -> Object) -> (Object -> Object) -> (Object -> Object) -> (a -> a -> res) -> String -> Object -> EvaluationState -> DataizeChain (Object, EvaluationState)
evaluatePartialBinaryDataizationFunChain :: (res -> Bytes) -> (Bytes -> a) -> (Bytes -> Object) -> (Object -> Object) -> (Object -> Object) -> (a -> a -> Maybe res) -> String -> Object -> EvaluationState -> DataizeChain (Object, EvaluationState)

-- | Unary functions operate on the given object without any additional
--   parameters
evaluateUnaryDataizationFunChain :: (res -> Bytes) -> (Bytes -> a) -> (Bytes -> Object) -> (Object -> Object) -> (a -> res) -> String -> Object -> EvaluationState -> DataizeChain (Object, EvaluationState)
evaluateIntIntIntFunChain :: (Int -> Int -> Int) -> String -> Object -> EvaluationState -> DataizeChain (Object, EvaluationState)
evaluateIntIntMaybeIntFunChain :: (Int -> Int -> Maybe Int) -> String -> Object -> EvaluationState -> DataizeChain (Object, EvaluationState)
evaluateIntIntBoolFunChain :: (Int -> Int -> Bool) -> String -> Object -> EvaluationState -> DataizeChain (Object, EvaluationState)
evaluateBytesBytesBytesFunChain :: (Int -> Int -> Int) -> String -> Object -> EvaluationState -> DataizeChain (Object, EvaluationState)
evaluateBytesBytesFunChain :: (Int -> Int) -> String -> Object -> EvaluationState -> DataizeChain (Object, EvaluationState)
evaluateFloatFloatFloatFunChain :: (Double -> Double -> Double) -> String -> Object -> EvaluationState -> DataizeChain (Object, EvaluationState)

-- | Like <a>evaluateDataizationFunChain</a> but specifically for the
--   built-in functions. This function is not safe. It returns undefined
--   for unknown functions
evaluateBuiltinFunChain :: String -> Object -> EvaluationState -> DataizeChain (Object, EvaluationState)
evaluateBuiltinFunChainUnknown :: String -> Object -> EvaluationState -> DataizeChain (Object, EvaluationState)

-- | Like <tt>evaluateDataizationFun</tt> but specifically for the built-in
--   functions. This function is not safe. It returns undefined for unknown
--   functions
evaluateBuiltinFun :: Context -> String -> Object -> EvaluationState -> (Object, EvaluationState)
evaluateIODataizationFunChain :: IO String -> Object -> EvaluationState -> DataizeChain (Object, EvaluationState)
extractRho :: Object -> Object
extractAlpha0 :: Object -> Object
extractLabel :: String -> Object -> Object

module Language.EO.Phi.Dataize.Atoms
knownAtomsList :: [(String, String -> Object -> EvaluationState -> DataizeChain (Object, EvaluationState))]

module Language.EO.Phi.Dataize.Context
knownAtomsMap :: Atoms
defaultContext :: [NamedRule] -> Object -> Context
mkEnabledAtoms :: [String] -> [String] -> Atoms

module Language.EO.Phi.Rules.RunYegor
runWithYegorRules :: (Context -> Object -> Object) -> Object -> IO ()
yegorRuleSet :: RuleSet
yegorRules :: [NamedRule]

module Language.EO.Phi

-- | Normalize an input ùúë-program.
normalize :: Program -> Program

-- | Parse a <a>Program</a> or return a parsing error.
parseProgram :: String -> Either String Program

-- | Parse an <a>Object</a> from a <a>String</a>. May throw an <a>error</a>
--   if input has a syntactical or lexical errors.
unsafeParseObject :: String -> Object

-- | Parse a <a>Program</a> from a <a>String</a>. May throw an <a>error</a>
--   if input has a syntactical or lexical errors.
unsafeParseProgram :: String -> Program
unsafeParseProgramFromFile :: FilePath -> IO Program

module Language.EO.Phi.Dependencies
bindingAttr :: Binding -> Maybe Attribute
zipBindings :: [Binding] -> [Binding] -> ([Binding], [(Binding, Binding)])
isPackage :: [Binding] -> Bool
isPackageBinding :: Binding -> Bool
mergeBinding :: Binding -> Binding -> Either String Binding
mergeBindings :: [Binding] -> [Binding] -> Either String [Binding]
deepMerge :: Program -> Program -> Either String Program
deepMergePrograms :: [Program] -> Either String Program

module Language.EO.Phi.TH
defaultOptions' :: Options
deriveJSON :: Name -> Q [Dec]
deriveFromJSON :: Name -> Q [Dec]

module Language.EO.Phi.Pipeline.EOTests.Data
data Pos
Pos :: FilePath -> Int -> Pos
[$sel:file:Pos] :: Pos -> FilePath
[$sel:line:Pos] :: Pos -> Int
data Program
Program :: Pos -> String -> String -> Program
[$sel:source:Program] :: Program -> Pos
[$sel:name:Program] :: Program -> String
[$sel:text:Program] :: Program -> String
data Test
Test :: String -> String -> String -> [Program] -> Test
[$sel:source:Test] :: Test -> String
[$sel:license:Test] :: Test -> String
[$sel:meta:Test] :: Test -> String
[$sel:programs:Test] :: Test -> [Program]
data TestContent
TestContent :: FilePath -> String -> [Program] -> TestContent
[$sel:source:TestContent] :: TestContent -> FilePath
[$sel:meta:TestContent] :: TestContent -> String
[$sel:programs:TestContent] :: TestContent -> [Program]
instance Data.Aeson.Types.ToJSON.ToJSON Language.EO.Phi.Pipeline.EOTests.Data.TestContent
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Pipeline.EOTests.Data.TestContent
instance GHC.Generics.Generic Language.EO.Phi.Pipeline.EOTests.Data.TestContent
instance GHC.Show.Show Language.EO.Phi.Pipeline.EOTests.Data.TestContent
instance Data.Aeson.Types.ToJSON.ToJSON Language.EO.Phi.Pipeline.EOTests.Data.Test
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Pipeline.EOTests.Data.Test
instance GHC.Generics.Generic Language.EO.Phi.Pipeline.EOTests.Data.Test
instance GHC.Show.Show Language.EO.Phi.Pipeline.EOTests.Data.Test
instance Data.Aeson.Types.ToJSON.ToJSON Language.EO.Phi.Pipeline.EOTests.Data.Program
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Pipeline.EOTests.Data.Program
instance GHC.Show.Show Language.EO.Phi.Pipeline.EOTests.Data.Pos
instance GHC.Generics.Generic Language.EO.Phi.Pipeline.EOTests.Data.Program
instance GHC.Show.Show Language.EO.Phi.Pipeline.EOTests.Data.Program
instance Data.Aeson.Types.ToJSON.ToJSON Language.EO.Phi.Pipeline.EOTests.Data.Pos
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Pipeline.EOTests.Data.Pos

module Language.EO.Phi.Metrics.Data
data Metrics a
Metrics :: a -> a -> a -> a -> Metrics a
[$sel:dataless:Metrics] :: Metrics a -> a
[$sel:applications:Metrics] :: Metrics a -> a
[$sel:formations:Metrics] :: Metrics a -> a
[$sel:dispatches:Metrics] :: Metrics a -> a
toListMetrics :: Metrics a -> [a]
type MetricsCount = Metrics Int
data BindingMetrics
BindingMetrics :: String -> MetricsCount -> BindingMetrics
[$sel:name:BindingMetrics] :: BindingMetrics -> String
[$sel:metrics:BindingMetrics] :: BindingMetrics -> MetricsCount
type Path = [String]
data BindingsByPathMetrics
BindingsByPathMetrics :: Path -> [BindingMetrics] -> BindingsByPathMetrics
[$sel:path:BindingsByPathMetrics] :: BindingsByPathMetrics -> Path
[$sel:bindingsMetrics:BindingsByPathMetrics] :: BindingsByPathMetrics -> [BindingMetrics]
splitStringOn :: Char -> String -> Path
splitPath :: String -> Path
data ObjectMetrics
ObjectMetrics :: Maybe BindingsByPathMetrics -> MetricsCount -> ObjectMetrics
[$sel:bindingsByPathMetrics:ObjectMetrics] :: ObjectMetrics -> Maybe BindingsByPathMetrics
[$sel:thisObjectMetrics:ObjectMetrics] :: ObjectMetrics -> MetricsCount
data ProgramMetrics
ProgramMetrics :: Maybe BindingsByPathMetrics -> MetricsCount -> ProgramMetrics
[$sel:bindingsByPathMetrics:ProgramMetrics] :: ProgramMetrics -> Maybe BindingsByPathMetrics
[$sel:programMetrics:ProgramMetrics] :: ProgramMetrics -> MetricsCount
instance Data.Aeson.Types.ToJSON.ToJSON Language.EO.Phi.Metrics.Data.ProgramMetrics
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Metrics.Data.ProgramMetrics
instance GHC.Classes.Eq Language.EO.Phi.Metrics.Data.ProgramMetrics
instance GHC.Generics.Generic Language.EO.Phi.Metrics.Data.ProgramMetrics
instance GHC.Show.Show Language.EO.Phi.Metrics.Data.ProgramMetrics
instance Data.Aeson.Types.ToJSON.ToJSON Language.EO.Phi.Metrics.Data.ObjectMetrics
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Metrics.Data.ObjectMetrics
instance GHC.Classes.Eq Language.EO.Phi.Metrics.Data.BindingsByPathMetrics
instance GHC.Generics.Generic Language.EO.Phi.Metrics.Data.BindingsByPathMetrics
instance GHC.Show.Show Language.EO.Phi.Metrics.Data.BindingsByPathMetrics
instance GHC.Classes.Eq Language.EO.Phi.Metrics.Data.ObjectMetrics
instance GHC.Generics.Generic Language.EO.Phi.Metrics.Data.ObjectMetrics
instance GHC.Show.Show Language.EO.Phi.Metrics.Data.ObjectMetrics
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Metrics.Data.BindingsByPathMetrics
instance Data.Aeson.Types.ToJSON.ToJSON Language.EO.Phi.Metrics.Data.BindingsByPathMetrics
instance Data.Aeson.Types.ToJSON.ToJSON Language.EO.Phi.Metrics.Data.BindingMetrics
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Metrics.Data.BindingMetrics
instance GHC.Classes.Eq Language.EO.Phi.Metrics.Data.BindingMetrics
instance GHC.Generics.Generic Language.EO.Phi.Metrics.Data.BindingMetrics
instance GHC.Show.Show Language.EO.Phi.Metrics.Data.BindingMetrics
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Language.EO.Phi.Metrics.Data.Metrics a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Language.EO.Phi.Metrics.Data.Metrics a)
instance GHC.Base.Applicative Language.EO.Phi.Metrics.Data.Metrics
instance GHC.Num.Num a => GHC.Num.Num (Language.EO.Phi.Metrics.Data.Metrics a)
instance GHC.Real.Fractional a => GHC.Real.Fractional (Language.EO.Phi.Metrics.Data.Metrics a)
instance GHC.Num.Num a => GHC.Base.Semigroup (Language.EO.Phi.Metrics.Data.Metrics a)
instance GHC.Num.Num a => GHC.Base.Monoid (Language.EO.Phi.Metrics.Data.Metrics a)
instance Data.Traversable.Traversable Language.EO.Phi.Metrics.Data.Metrics
instance Data.Foldable.Foldable Language.EO.Phi.Metrics.Data.Metrics
instance GHC.Base.Functor Language.EO.Phi.Metrics.Data.Metrics
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.EO.Phi.Metrics.Data.Metrics a)
instance GHC.Generics.Generic (Language.EO.Phi.Metrics.Data.Metrics a)
instance GHC.Show.Show a => GHC.Show.Show (Language.EO.Phi.Metrics.Data.Metrics a)

module Language.EO.Phi.Pipeline.Config
data TestSetPhi
TestSetPhi :: FilePath -> FilePath -> Maybe String -> Maybe String -> TestSetPhi
[$sel:initial:TestSetPhi] :: TestSetPhi -> FilePath
[$sel:normalized:TestSetPhi] :: TestSetPhi -> FilePath
[$sel:bindingsPathInitial:TestSetPhi] :: TestSetPhi -> Maybe String
[$sel:bindingsPathNormalized:TestSetPhi] :: TestSetPhi -> Maybe String
data MetricsChangeCategory a
MetricsChange'Good :: a -> MetricsChangeCategory a
[$sel:change:MetricsChange'Good] :: MetricsChangeCategory a -> a
MetricsChange'Bad :: a -> MetricsChangeCategory a
[$sel:change:MetricsChange'Good] :: MetricsChangeCategory a -> a
MetricsChange'NA :: MetricsChangeCategory a
type MetricsChange = Metrics Percent
newtype Percent
Percent :: Double -> Percent
[$sel:percent:Percent] :: Percent -> Double
roundToStr :: Int -> Double -> String
type MetricsChangeCategorized = Metrics (MetricsChangeCategory Percent)
data ReportInput
ReportInput :: Maybe FilePath -> Maybe FilePath -> ReportInput
[$sel:js:ReportInput] :: ReportInput -> Maybe FilePath
[$sel:css:ReportInput] :: ReportInput -> Maybe FilePath
data ReportOutput
ReportOutput :: Maybe FilePath -> Maybe FilePath -> Maybe FilePath -> ReportOutput
[$sel:html:ReportOutput] :: ReportOutput -> Maybe FilePath
[$sel:json:ReportOutput] :: ReportOutput -> Maybe FilePath
[$sel:markdown:ReportOutput] :: ReportOutput -> Maybe FilePath
data ReportConfig
ReportConfig :: Maybe ReportInput -> ReportOutput -> MetricsChange -> Percent -> ReportConfig
[$sel:input:ReportConfig] :: ReportConfig -> Maybe ReportInput
[$sel:output:ReportConfig] :: ReportConfig -> ReportOutput
[$sel:expectedMetricsChange:ReportConfig] :: ReportConfig -> MetricsChange
[$sel:expectedImprovedProgramsPercentage:ReportConfig] :: ReportConfig -> Percent
data TestSetEO
TestSetEO :: FilePath -> FilePath -> FilePath -> Maybe [String] -> Maybe [String] -> TestSetEO
[$sel:original:TestSetEO] :: TestSetEO -> FilePath
[$sel:yaml:TestSetEO] :: TestSetEO -> FilePath
[$sel:filtered:TestSetEO] :: TestSetEO -> FilePath

-- | Program names to include.
--   
--   <a>Nothing</a> is equivalent to all programs.
[$sel:include:TestSetEO] :: TestSetEO -> Maybe [String]

-- | Program names to exclude
--   
--   <a>Nothing</a> is equivalent to no programs.
[$sel:exclude:TestSetEO] :: TestSetEO -> Maybe [String]
data AtomsSet
AtomsSet :: Maybe [String] -> Maybe [String] -> AtomsSet
[$sel:enable:AtomsSet] :: AtomsSet -> Maybe [String]
[$sel:disable:AtomsSet] :: AtomsSet -> Maybe [String]
data PathPrefixEO
PathPrefixEO :: FilePath -> FilePath -> FilePath -> PathPrefixEO
[$sel:original:PathPrefixEO] :: PathPrefixEO -> FilePath
[$sel:yaml:PathPrefixEO] :: PathPrefixEO -> FilePath
[$sel:filtered:PathPrefixEO] :: PathPrefixEO -> FilePath
data PathPrefixPhi
PathPrefixPhi :: FilePath -> FilePath -> PathPrefixPhi
[$sel:initial:PathPrefixPhi] :: PathPrefixPhi -> FilePath
[$sel:normalized:PathPrefixPhi] :: PathPrefixPhi -> FilePath
data PathPrefix
PathPrefix :: PathPrefixEO -> PathPrefixPhi -> PathPrefix
[$sel:eo:PathPrefix] :: PathPrefix -> PathPrefixEO
[$sel:phi:PathPrefix] :: PathPrefix -> PathPrefixPhi
data Common
Common :: PathPrefix -> Maybe String -> Common
[$sel:pathPrefix:Common] :: Common -> PathPrefix
[$sel:bindingsPath:Common] :: Common -> Maybe String
data Individual
Individual :: String -> Maybe Bool -> Maybe [String] -> Maybe [String] -> Maybe AtomsSet -> Individual
[$sel:name:Individual] :: Individual -> String
[$sel:enable:Individual] :: Individual -> Maybe Bool
[$sel:include:Individual] :: Individual -> Maybe [String]
[$sel:exclude:Individual] :: Individual -> Maybe [String]
[$sel:atoms:Individual] :: Individual -> Maybe AtomsSet
data TestSet
TestSetExtended :: TestSetEO -> TestSetPhi -> Maybe AtomsSet -> Maybe Bool -> TestSet
[$sel:eo:TestSetExtended] :: TestSet -> TestSetEO
[$sel:phi:TestSetExtended] :: TestSet -> TestSetPhi
[$sel:atoms:TestSetExtended] :: TestSet -> Maybe AtomsSet

-- | Whether to enable this test set.
[$sel:enable:TestSetExtended] :: TestSet -> Maybe Bool
TestSetCompact :: Common -> [Individual] -> TestSet
[$sel:common:TestSetExtended] :: TestSet -> Common
[$sel:individual:TestSetExtended] :: TestSet -> [Individual]
data PipelineConfig
PipelineConfig :: ReportConfig -> [TestSet] -> PipelineConfig
[$sel:report:PipelineConfig] :: PipelineConfig -> ReportConfig
[$sel:testSets:PipelineConfig] :: PipelineConfig -> [TestSet]
data ReportFormat
ReportFormat'Html :: ReportFormat

-- | GitHub Flavored Markdown
ReportFormat'Markdown :: ReportFormat
split :: forall a. (a -> Bool) -> [a] -> [[a]]
toExtended :: PipelineConfig -> PipelineConfig
readPipelineConfig :: MonadIO m => FilePath -> m PipelineConfig
instance GHC.Classes.Eq Language.EO.Phi.Pipeline.Config.ReportFormat
instance Data.Aeson.Types.ToJSON.ToJSON Language.EO.Phi.Pipeline.Config.PipelineConfig
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Pipeline.Config.PipelineConfig
instance GHC.Generics.Generic Language.EO.Phi.Pipeline.Config.PipelineConfig
instance GHC.Show.Show Language.EO.Phi.Pipeline.Config.PipelineConfig
instance Data.Aeson.Types.ToJSON.ToJSON Language.EO.Phi.Pipeline.Config.TestSet
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Pipeline.Config.TestSet
instance GHC.Generics.Generic Language.EO.Phi.Pipeline.Config.TestSet
instance GHC.Show.Show Language.EO.Phi.Pipeline.Config.TestSet
instance Data.Aeson.Types.ToJSON.ToJSON Language.EO.Phi.Pipeline.Config.Individual
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Pipeline.Config.Individual
instance GHC.Generics.Generic Language.EO.Phi.Pipeline.Config.Individual
instance GHC.Show.Show Language.EO.Phi.Pipeline.Config.Individual
instance Data.Aeson.Types.ToJSON.ToJSON Language.EO.Phi.Pipeline.Config.Common
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Pipeline.Config.Common
instance GHC.Generics.Generic Language.EO.Phi.Pipeline.Config.Common
instance GHC.Show.Show Language.EO.Phi.Pipeline.Config.Common
instance Data.Aeson.Types.ToJSON.ToJSON Language.EO.Phi.Pipeline.Config.PathPrefix
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Pipeline.Config.PathPrefix
instance GHC.Generics.Generic Language.EO.Phi.Pipeline.Config.PathPrefix
instance GHC.Show.Show Language.EO.Phi.Pipeline.Config.PathPrefix
instance Data.Aeson.Types.ToJSON.ToJSON Language.EO.Phi.Pipeline.Config.PathPrefixPhi
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Pipeline.Config.PathPrefixPhi
instance GHC.Generics.Generic Language.EO.Phi.Pipeline.Config.PathPrefixPhi
instance GHC.Show.Show Language.EO.Phi.Pipeline.Config.PathPrefixPhi
instance Data.Aeson.Types.ToJSON.ToJSON Language.EO.Phi.Pipeline.Config.PathPrefixEO
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Pipeline.Config.PathPrefixEO
instance GHC.Generics.Generic Language.EO.Phi.Pipeline.Config.PathPrefixEO
instance GHC.Show.Show Language.EO.Phi.Pipeline.Config.PathPrefixEO
instance Data.Aeson.Types.ToJSON.ToJSON Language.EO.Phi.Pipeline.Config.AtomsSet
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Pipeline.Config.AtomsSet
instance GHC.Generics.Generic Language.EO.Phi.Pipeline.Config.AtomsSet
instance GHC.Show.Show Language.EO.Phi.Pipeline.Config.AtomsSet
instance Data.Aeson.Types.ToJSON.ToJSON Language.EO.Phi.Pipeline.Config.TestSetEO
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Pipeline.Config.TestSetEO
instance GHC.Generics.Generic Language.EO.Phi.Pipeline.Config.TestSetEO
instance GHC.Show.Show Language.EO.Phi.Pipeline.Config.TestSetEO
instance Data.Aeson.Types.ToJSON.ToJSON Language.EO.Phi.Pipeline.Config.ReportConfig
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Pipeline.Config.ReportConfig
instance GHC.Generics.Generic Language.EO.Phi.Pipeline.Config.ReportConfig
instance GHC.Show.Show Language.EO.Phi.Pipeline.Config.ReportConfig
instance Data.Aeson.Types.ToJSON.ToJSON Language.EO.Phi.Pipeline.Config.ReportOutput
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Pipeline.Config.ReportOutput
instance GHC.Generics.Generic Language.EO.Phi.Pipeline.Config.ReportOutput
instance GHC.Show.Show Language.EO.Phi.Pipeline.Config.ReportOutput
instance Data.Aeson.Types.ToJSON.ToJSON Language.EO.Phi.Pipeline.Config.ReportInput
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Pipeline.Config.ReportInput
instance GHC.Float.RealFloat Language.EO.Phi.Pipeline.Config.Percent
instance GHC.Real.RealFrac Language.EO.Phi.Pipeline.Config.Percent
instance GHC.Real.Real Language.EO.Phi.Pipeline.Config.Percent
instance GHC.Classes.Ord Language.EO.Phi.Pipeline.Config.Percent
instance GHC.Classes.Eq Language.EO.Phi.Pipeline.Config.Percent
instance GHC.Float.Floating Language.EO.Phi.Pipeline.Config.Percent
instance GHC.Real.Fractional Language.EO.Phi.Pipeline.Config.Percent
instance GHC.Num.Num Language.EO.Phi.Pipeline.Config.Percent
instance Data.Aeson.Types.ToJSON.ToJSON Language.EO.Phi.Pipeline.Config.Percent
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Pipeline.Config.Percent
instance GHC.Generics.Generic Language.EO.Phi.Pipeline.Config.ReportInput
instance GHC.Show.Show Language.EO.Phi.Pipeline.Config.ReportInput
instance GHC.Show.Show Language.EO.Phi.Pipeline.Config.Percent
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Language.EO.Phi.Pipeline.Config.MetricsChangeCategory a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Language.EO.Phi.Pipeline.Config.MetricsChangeCategory a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.EO.Phi.Pipeline.Config.MetricsChangeCategory a)
instance GHC.Generics.Generic (Language.EO.Phi.Pipeline.Config.MetricsChangeCategory a)
instance GHC.Show.Show a => GHC.Show.Show (Language.EO.Phi.Pipeline.Config.MetricsChangeCategory a)
instance Data.Aeson.Types.ToJSON.ToJSON Language.EO.Phi.Pipeline.Config.TestSetPhi
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Pipeline.Config.TestSetPhi
instance GHC.Generics.Generic Language.EO.Phi.Pipeline.Config.TestSetPhi
instance GHC.Show.Show Language.EO.Phi.Pipeline.Config.TestSetPhi

module Language.EO.Phi.Report.Data
data ReportRow
ReportRow :: Maybe FilePath -> Maybe FilePath -> Maybe Path -> Maybe Path -> Maybe String -> Maybe String -> MetricsChangeCategorized -> Metrics Int -> Metrics Int -> ReportRow
[$sel:fileInitial:ReportRow] :: ReportRow -> Maybe FilePath
[$sel:fileNormalized:ReportRow] :: ReportRow -> Maybe FilePath
[$sel:bindingsPathInitial:ReportRow] :: ReportRow -> Maybe Path
[$sel:bindingsPathNormalized:ReportRow] :: ReportRow -> Maybe Path
[$sel:attributeInitial:ReportRow] :: ReportRow -> Maybe String
[$sel:attributeNormalized:ReportRow] :: ReportRow -> Maybe String
[$sel:metricsChange:ReportRow] :: ReportRow -> MetricsChangeCategorized
[$sel:metricsInitial:ReportRow] :: ReportRow -> Metrics Int
[$sel:metricsNormalized:ReportRow] :: ReportRow -> Metrics Int
data ProgramReport
ProgramReport :: ReportRow -> [ReportRow] -> ProgramReport
[$sel:programRow:ProgramReport] :: ProgramReport -> ReportRow
[$sel:bindingsRows:ProgramReport] :: ProgramReport -> [ReportRow]
data Report
Report :: ReportRow -> [ProgramReport] -> Report
[$sel:totalRow:Report] :: Report -> ReportRow
[$sel:programReports:Report] :: Report -> [ProgramReport]
calculateMetricsChange :: MetricsChange -> MetricsCount -> MetricsCount -> MetricsChangeCategorized
makeProgramReport :: PipelineConfig -> TestSetPhi -> ProgramMetrics -> ProgramMetrics -> ProgramReport
makeReport :: PipelineConfig -> [ProgramReport] -> Report
instance Data.Aeson.Types.ToJSON.ToJSON Language.EO.Phi.Report.Data.Report
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Report.Data.Report
instance Data.Aeson.Types.ToJSON.ToJSON Language.EO.Phi.Report.Data.ProgramReport
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Report.Data.ProgramReport
instance Data.Aeson.Types.ToJSON.ToJSON Language.EO.Phi.Report.Data.ReportRow
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Report.Data.ReportRow

module Language.EO.Phi.Report.Html

-- | JavaScript file to embed into HTML reports
reportJS :: String

-- | CSS file to embed into HTML reports
reportCSS :: String
metricsNames :: Metrics String
toHtmlReportTableHeader :: Html
class (Num a) => ToDataSort a
toDataSort :: ToDataSort a => a -> Integer
mkDataSortAttribute :: AttributeValue -> Attribute
toHtmlChange :: forall a. (ToMarkup a, ToDataSort a) => ReportFormat -> MetricsChangeCategory a -> Html
toHtmlMetricsChange :: ReportFormat -> MetricsChangeCategorized -> [Html]
toHtmlMetrics :: MetricsCount -> [Html]
toHtmlReportRow :: ReportFormat -> Int -> ReportRow -> Html
toHtmlReport :: ReportFormat -> PipelineConfig -> Report -> Html

-- | <pre>
--   &gt;&gt;&gt; renderHtml (mkItem 10 "foo" 4)
--   "&lt;li&gt;&lt;b&gt;foo: &lt;/b&gt;4 (40.00%)&lt;/li&gt;"
--   </pre>
mkItem :: Int -> String -> Int -> Html
mkPercentItem :: String -> Percent -> Html
mkPercentage :: Int -> Int -> Percent

-- | <pre>
--   &gt;&gt;&gt; mkNumber 3 5
--   "3 (60.00%)"
--   </pre>
mkNumber :: Int -> Int -> String
toStringReport :: ReportFormat -> PipelineConfig -> Report -> String
instance Language.EO.Phi.Report.Html.ToDataSort GHC.Types.Double
instance Language.EO.Phi.Report.Html.ToDataSort Language.EO.Phi.Pipeline.Config.Percent
instance Language.EO.Phi.Report.Html.ToDataSort GHC.Num.Integer.Integer
instance Text.Blaze.ToMarkup Language.EO.Phi.Pipeline.Config.Percent

module Language.EO.Phi.Pipeline.EOTests.PrepareTests
prepareTests :: PipelineConfig -> IO ()
parseProgramsRaw :: ([(Int, [String])], (Int, [[Char]]), Int) -> [[Char]] -> [(Int, String)]
parseTest' :: FilePath -> [String] -> Test
parseTest :: FilePath -> IO Test

module Language.EO.Phi.Pipeline.Dataize.PrintConfigs
printDataizeConfigs :: PipelineConfig -> [String] -> Bool -> IO ()

module Language.EO.Phi.Metrics.Collect
type HeightSafe = Maybe Int
count :: (a -> Bool) -> [a] -> Int
getHeight :: [Binding] -> [HeightSafe] -> HeightSafe
countDataless :: HeightSafe -> Int
type InspectM = State MetricsCount HeightSafe
class Inspectable a
inspect :: Inspectable a => a -> InspectM

-- | Get metrics for an object
--   
--   <pre>
--   &gt;&gt;&gt; getThisObjectMetrics "‚ü¶ Œ±0 ‚Ü¶ Œæ, Œ±0 ‚Ü¶ Œ¶.org.eolang.bytes( Œî ‚§ç 00- ) ‚üß"
--   Metrics {dataless = 1, applications = 1, formations = 1, dispatches = 3}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getThisObjectMetrics "‚ü¶ Œ±0 ‚Ü¶ Œæ, Œî ‚§ç 00- ‚üß"
--   Metrics {dataless = 0, applications = 0, formations = 1, dispatches = 0}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getThisObjectMetrics "‚ü¶ Œ±0 ‚Ü¶ Œæ, Œ±1 ‚Ü¶ ‚ü¶ Œî ‚§ç 00- ‚üß ‚üß"
--   Metrics {dataless = 0, applications = 0, formations = 2, dispatches = 0}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getThisObjectMetrics "‚ü¶ Œ±0 ‚Ü¶ Œæ, Œ±1 ‚Ü¶ ‚ü¶ Œ±2 ‚Ü¶ ‚ü¶ Œî ‚§ç 00- ‚üß ‚üß ‚üß"
--   Metrics {dataless = 1, applications = 0, formations = 3, dispatches = 0}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getThisObjectMetrics "‚ü¶ Œî ‚§ç 00- ‚üß"
--   Metrics {dataless = 0, applications = 0, formations = 1, dispatches = 0}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getThisObjectMetrics "‚ü¶ Œ±0 ‚Ü¶ ‚ü¶ Œ±0 ‚Ü¶ ‚àÖ ‚üß ‚üß"
--   Metrics {dataless = 2, applications = 0, formations = 2, dispatches = 0}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getThisObjectMetrics "‚ü¶ Œ±0 ‚Ü¶ ‚ü¶ Œ±0 ‚Ü¶ ‚ü¶ Œ±0 ‚Ü¶ ‚àÖ ‚üß ‚üß ‚üß"
--   Metrics {dataless = 3, applications = 0, formations = 3, dispatches = 0}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getThisObjectMetrics "‚ü¶ Œ±0 ‚Ü¶ ‚ü¶ Œ±0 ‚Ü¶ ‚ü¶ Œ±0 ‚Ü¶ ‚ü¶ Œ±0 ‚Ü¶ ‚àÖ ‚üß ‚üß ‚üß ‚üß"
--   Metrics {dataless = 4, applications = 0, formations = 4, dispatches = 0}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getThisObjectMetrics "‚ü¶ org ‚Ü¶ ‚ü¶ ‚üß ‚üß"
--   Metrics {dataless = 2, applications = 0, formations = 2, dispatches = 0}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getThisObjectMetrics "‚ü¶ a ‚Ü¶ ‚ü¶ b ‚Ü¶ ‚ü¶ c ‚Ü¶ ‚àÖ, d ‚Ü¶ ‚ü¶ œÜ ‚Ü¶ Œæ.œÅ.c ‚üß ‚üß, e ‚Ü¶ Œæ.b(c ‚Ü¶ ‚ü¶‚üß).d ‚üß.e ‚üß"
--   Metrics {dataless = 5, applications = 1, formations = 5, dispatches = 5}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getThisObjectMetrics "‚ü¶ Œ±0 ‚Ü¶ Œ¶.something(Œ±1 ‚Ü¶ ‚ü¶ Œ±2 ‚Ü¶ ‚ü¶ Œ±3 ‚Ü¶ ‚ü¶ Œî ‚§ç 01- ‚üß ‚üß ‚üß) ‚üß"
--   Metrics {dataless = 2, applications = 1, formations = 4, dispatches = 1}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getThisObjectMetrics "‚ü¶ a ‚Ü¶ ‚ü¶ b ‚Ü¶ ‚ü¶ c ‚Ü¶ ‚àÖ, d ‚Ü¶ ‚ü¶ œÜ ‚Ü¶ Œæ.œÅ.c, Œî ‚§ç 01- ‚üß ‚üß, e ‚Ü¶ Œæ.b(c ‚Ü¶ ‚ü¶ Œî ‚§ç 01- ‚üß).d ‚üß.e ‚üß"
--   Metrics {dataless = 2, applications = 1, formations = 5, dispatches = 5}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getThisObjectMetrics "‚ü¶ org ‚Ü¶ ‚ü¶ Œî ‚§ç 01-, c ‚Ü¶ ‚àÖ ‚üß(c ‚Ü¶ ‚ü¶ ‚üß) ‚üß"
--   Metrics {dataless = 2, applications = 1, formations = 3, dispatches = 0}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getThisObjectMetrics "‚ü¶ Œ±0 ‚Ü¶ ‚ü¶ Œ±0 ‚Ü¶ ‚ü¶ Œ±0 ‚Ü¶ ‚ü¶ Œ±0 ‚Ü¶ ‚ü¶ Œî ‚§ç 01- ‚üß.a ‚üß ‚üß ‚üß ‚üß"
--   Metrics {dataless = 4, applications = 0, formations = 5, dispatches = 1}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getThisObjectMetrics "‚ü¶ Œ±0 ‚Ü¶ ‚ü¶ Œ±0 ‚Ü¶ ‚ü¶ ‚üß.a ‚üß, Œ±0 ‚Ü¶ ‚ü¶ Œî ‚§ç 01- ‚üß.b ‚üß"
--   Metrics {dataless = 3, applications = 0, formations = 4, dispatches = 2}
--   </pre>
getThisObjectMetrics :: Object -> MetricsCount

-- | Get an object by a path within a given object.
--   
--   If no object is accessible by the path, return the path that led to a
--   non-formation. &gt;&gt;&gt; flip getObjectByPath ["org", "eolang"] "‚ü¶
--   org ‚Ü¶ ‚ü¶ eolang ‚Ü¶ ‚ü¶ x ‚Ü¶ ‚ü¶ œÜ ‚Ü¶ Œ¶.org.eolang.bool ( Œ±0 ‚Ü¶
--   Œ¶.org.eolang.bytes (Œî ‚§ç 01-) ) ‚üß, z ‚Ü¶ ‚ü¶ y ‚Ü¶ ‚ü¶ x ‚Ü¶ ‚àÖ, œÜ ‚Ü¶ Œæ.x ‚üß, œÜ ‚Ü¶
--   Œ¶.org.eolang.bool ( Œ±0 ‚Ü¶ Œ¶.org.eolang.bytes (Œî ‚§ç 01-) ) ‚üß, Œª ‚§ç Package
--   ‚üß, Œª ‚§ç Package ‚üß‚üß" Right (Formation [AlphaBinding (AttributeNoSugar
--   (Label (LabelId "x"))) (Formation [AlphaBinding (AttributeNoSugar Phi)
--   (Application (ObjectDispatch (ObjectDispatch (ObjectDispatch
--   GlobalObject (Label (LabelId "org"))) (Label (LabelId "eolang")))
--   (Label (LabelId "bool"))) [AlphaBinding (AttributeNoSugar (Alpha
--   (AlphaIndex "945&amp;0"))) (Application (ObjectDispatch
--   (ObjectDispatch (ObjectDispatch GlobalObject (Label (LabelId "org")))
--   (Label (LabelId "eolang"))) (Label (LabelId "bytes"))) [DeltaBinding
--   (Bytes "01-")])])]),AlphaBinding (AttributeNoSugar (Label (LabelId
--   "z"))) (Formation [AlphaBinding (AttributeNoSugar (Label (LabelId
--   "y"))) (Formation [EmptyBinding (Label (LabelId "x")),AlphaBinding
--   (AttributeNoSugar Phi) (ObjectDispatch ThisObject (Label (LabelId
--   "x")))]),AlphaBinding (AttributeNoSugar Phi) (Application
--   (ObjectDispatch (ObjectDispatch (ObjectDispatch GlobalObject (Label
--   (LabelId "org"))) (Label (LabelId "eolang"))) (Label (LabelId
--   "bool"))) [AlphaBinding (AttributeNoSugar (Alpha (AlphaIndex
--   "945&amp;0"))) (Application (ObjectDispatch (ObjectDispatch
--   (ObjectDispatch GlobalObject (Label (LabelId "org"))) (Label (LabelId
--   "eolang"))) (Label (LabelId "bytes"))) [DeltaBinding (Bytes
--   "01-")])])]),LambdaBinding (Function <a>Package</a>)])
--   
--   <pre>
--   &gt;&gt;&gt; flip getObjectByPath ["a"] "‚ü¶ a ‚Ü¶ ‚ü¶ b ‚Ü¶ ‚ü¶ c ‚Ü¶ ‚àÖ, d ‚Ü¶ ‚ü¶ œÜ ‚Ü¶ Œæ.œÅ.c ‚üß ‚üß, e ‚Ü¶ Œæ.b(c ‚Ü¶ ‚ü¶‚üß).d ‚üß.e ‚üß"
--   Left ["a"]
--   </pre>
getObjectByPath :: Object -> Path -> Either Path Object

-- | Get metrics for bindings of a formation that is accessible by a path
--   within a given object.
--   
--   If no formation is accessible by the path, return the path that led to
--   a non-formation. &gt;&gt;&gt; flip getBindingsByPathMetrics ["a"] "‚ü¶ a
--   ‚Ü¶ ‚ü¶ b ‚Ü¶ ‚ü¶ c ‚Ü¶ ‚àÖ, d ‚Ü¶ ‚ü¶ œÜ ‚Ü¶ Œæ.œÅ.c ‚üß ‚üß, e ‚Ü¶ Œæ.b(c ‚Ü¶ ‚ü¶‚üß).d ‚üß.e ‚üß" Left
--   ["a"]
--   
--   <pre>
--   &gt;&gt;&gt; flip getBindingsByPathMetrics ["a"] "‚ü¶ a ‚Ü¶ ‚ü¶ b ‚Ü¶ ‚ü¶ c ‚Ü¶ ‚àÖ, d ‚Ü¶ ‚ü¶ œÜ ‚Ü¶ Œæ.œÅ.c ‚üß ‚üß, e ‚Ü¶ Œæ.b(c ‚Ü¶ ‚ü¶‚üß).d ‚üß ‚üß"
--   Right (BindingsByPathMetrics {path = ["a"], bindingsMetrics = [BindingMetrics {name = "b", metrics = Metrics {dataless = 2, applications = 0, formations = 2, dispatches = 2}},BindingMetrics {name = "e", metrics = Metrics {dataless = 1, applications = 1, formations = 1, dispatches = 2}}]})
--   </pre>
getBindingsByPathMetrics :: Object -> Path -> Either Path BindingsByPathMetrics

-- | Get metrics for an object and for bindings of a formation accessible
--   by a given path.
--   
--   Combine metrics produced by <a>getThisObjectMetrics</a> and
--   <a>getBindingsByPathMetrics</a>.
--   
--   If no formation is accessible by the path, return the path that led to
--   a non-formation. &gt;&gt;&gt; flip getObjectMetrics (Just ["a"]) "‚ü¶ a
--   ‚Ü¶ ‚ü¶ b ‚Ü¶ ‚ü¶ c ‚Ü¶ ‚àÖ, d ‚Ü¶ ‚ü¶ œÜ ‚Ü¶ Œæ.œÅ.c ‚üß ‚üß, e ‚Ü¶ Œæ.b(c ‚Ü¶ ‚ü¶‚üß).d ‚üß.e ‚üß" Left
--   ["a"]
--   
--   <pre>
--   &gt;&gt;&gt; flip getObjectMetrics (Just ["a"]) "‚ü¶ a ‚Ü¶ ‚ü¶ b ‚Ü¶ ‚ü¶ c ‚Ü¶ ‚àÖ, d ‚Ü¶ ‚ü¶ œÜ ‚Ü¶ Œæ.œÅ.c ‚üß ‚üß, e ‚Ü¶ Œæ.b(c ‚Ü¶ ‚ü¶‚üß).d ‚üß ‚üß"
--   Right (ObjectMetrics {bindingsByPathMetrics = Just (BindingsByPathMetrics {path = ["a"], bindingsMetrics = [BindingMetrics {name = "b", metrics = Metrics {dataless = 2, applications = 0, formations = 2, dispatches = 2}},BindingMetrics {name = "e", metrics = Metrics {dataless = 1, applications = 1, formations = 1, dispatches = 2}}]}), thisObjectMetrics = Metrics {dataless = 5, applications = 1, formations = 5, dispatches = 4}})
--   </pre>
getObjectMetrics :: Object -> Maybe Path -> Either Path ObjectMetrics

-- | Get metrics for a program and for bindings of a formation accessible
--   by the given path.
--   
--   Combine metrics produced by <a>getThisObjectMetrics</a> and
--   <a>getBindingsByPathMetrics</a>.
--   
--   If no formation is accessible by the path, return the path that led to
--   a non-formation. &gt;&gt;&gt; flip getProgramMetrics (Just ["org",
--   "eolang"]) "{‚ü¶ org ‚Ü¶ ‚ü¶ eolang ‚Ü¶ ‚ü¶ x ‚Ü¶ ‚ü¶ œÜ ‚Ü¶ Œ¶.org.eolang.bool ( Œ±0 ‚Ü¶
--   Œ¶.org.eolang.bytes (Œî ‚§ç 01-) ) ‚üß, z ‚Ü¶ ‚ü¶ y ‚Ü¶ ‚ü¶ x ‚Ü¶ ‚àÖ, œÜ ‚Ü¶ Œæ.x ‚üß, œÜ ‚Ü¶
--   Œ¶.org.eolang.bool ( Œ±0 ‚Ü¶ Œ¶.org.eolang.bytes (Œî ‚§ç 01-) ) ‚üß, Œª ‚§ç Package
--   ‚üß, Œª ‚§ç Package ‚üß‚üß }" Right (ProgramMetrics {bindingsByPathMetrics =
--   Just (BindingsByPathMetrics {path = ["org","eolang"], bindingsMetrics
--   = [BindingMetrics {name = "x", metrics = Metrics {dataless = 1,
--   applications = 2, formations = 1, dispatches = 6}},BindingMetrics
--   {name = "z", metrics = Metrics {dataless = 2, applications = 2,
--   formations = 2, dispatches = 7}}]}), programMetrics = Metrics
--   {dataless = 6, applications = 4, formations = 6, dispatches = 13}})
--   
--   <pre>
--   &gt;&gt;&gt; flip getProgramMetrics (Just ["a"]) "{‚ü¶ a ‚Ü¶ ‚ü¶ b ‚Ü¶ ‚ü¶ c ‚Ü¶ ‚àÖ, d ‚Ü¶ ‚ü¶ œÜ ‚Ü¶ Œæ.œÅ.c ‚üß ‚üß, e ‚Ü¶ Œæ.b(c ‚Ü¶ ‚ü¶‚üß).d ‚üß.e ‚üß}"
--   Left ["a"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; flip getProgramMetrics (Just ["a"]) "{‚ü¶ a ‚Ü¶ ‚ü¶ b ‚Ü¶ ‚ü¶ c ‚Ü¶ ‚àÖ, d ‚Ü¶ ‚ü¶ œÜ ‚Ü¶ Œæ.œÅ.c ‚üß ‚üß, e ‚Ü¶ Œæ.b(c ‚Ü¶ ‚ü¶‚üß).d ‚üß ‚üß}"
--   Right (ProgramMetrics {bindingsByPathMetrics = Just (BindingsByPathMetrics {path = ["a"], bindingsMetrics = [BindingMetrics {name = "b", metrics = Metrics {dataless = 2, applications = 0, formations = 2, dispatches = 2}},BindingMetrics {name = "e", metrics = Metrics {dataless = 1, applications = 1, formations = 1, dispatches = 2}}]}), programMetrics = Metrics {dataless = 5, applications = 1, formations = 5, dispatches = 4}})
--   </pre>
getProgramMetrics :: Program -> Maybe Path -> Either Path ProgramMetrics
instance Language.EO.Phi.Metrics.Collect.Inspectable Language.EO.Phi.Syntax.Abs.Binding
instance Language.EO.Phi.Metrics.Collect.Inspectable Language.EO.Phi.Syntax.Abs.Object

module Language.EO.Phi.ToLaTeX
newtype LaTeX
LaTeX :: String -> LaTeX
[unLaTeX] :: LaTeX -> String
class ToLatex a
toLatex :: ToLatex a => a -> LaTeX
toLatexString :: ToLatex a => a -> String
removeOrgEolang :: String -> String
substituteTau :: String -> String
removeExclamationsMarks :: String -> String
removeAlpha :: String -> String
latexToString :: LaTeX -> String
inMathMode :: LaTeX -> LaTeX
isNonEmptyContext :: Maybe RuleContext -> Bool
ruleToLatexCompact :: Rule -> LaTeX
rulesToLatexCompact :: [Rule] -> LaTeX
instance GHC.Base.Monoid Language.EO.Phi.ToLaTeX.LaTeX
instance GHC.Base.Semigroup Language.EO.Phi.ToLaTeX.LaTeX
instance Data.String.IsString Language.EO.Phi.ToLaTeX.LaTeX
instance Language.EO.Phi.ToLaTeX.ToLatex Language.EO.Phi.Syntax.Abs.Program
instance Language.EO.Phi.ToLaTeX.ToLatex Language.EO.Phi.Syntax.Abs.Attribute
instance Language.EO.Phi.ToLaTeX.ToLatex Language.EO.Phi.Syntax.Abs.Binding
instance Language.EO.Phi.ToLaTeX.ToLatex Language.EO.Phi.Syntax.Abs.Object
instance Language.EO.Phi.ToLaTeX.ToLatex Language.EO.Phi.Rules.Yaml.RuleContext
instance Language.EO.Phi.ToLaTeX.ToLatex Language.EO.Phi.Syntax.Abs.RuleAttribute
instance Language.EO.Phi.ToLaTeX.ToLatex Language.EO.Phi.Rules.Yaml.Condition
instance Language.EO.Phi.ToLaTeX.ToLatex Language.EO.Phi.Rules.Yaml.Rule
instance Language.EO.Phi.ToLaTeX.ToLatex [Language.EO.Phi.Rules.Yaml.Rule]
instance GHC.Show.Show Language.EO.Phi.ToLaTeX.LaTeX

module Language.EO.Test.Yaml
fileTests :: FilePath -> IO RuleSet
directoryTests :: FilePath -> IO [RuleSet]

module Language.EO.Test.YamlSpec
spec :: [FilePath] -> Spec
