-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Get your IO right on the first try
--   
--   This minimalistic library helps you navigate the world of text
--   encodings avoiding <tt>invalid argument (invalid byte sequence)</tt>
--   and <tt>invalid argument (invalid character)</tt> in runtime.
--   
--   See <a>this blog post</a> for why this library exists and what exactly
--   it does.
--   
--   The two most important modules are:
--   
--   <ul>
--   <li><a>Main.Utf8</a></li>
--   <li><a>System.IO.Utf8</a></li>
--   </ul>
@package with-utf8
@version 1.0.2.4


-- | Internal functions that implement encoding selection logic.
module System.IO.Utf8.Internal

-- | What to do with the encoding of the handle.
--   
--   We return new encoding as string to simplify testing, because, it
--   turns out, when you make an encoding with some name, the resulting
--   encoding can have a different name.
--   
--   The second constructor also contains the old encoding as a proof that
--   the encoding is set to a new one only if there was a previous one in
--   the first place. You probably think I am crazy, but I am not, it is
--   just the simplest way to make the <tt>hSetBestUtf8Enc</tt> easy to
--   write.
data EncodingAction

-- | Do nothing.
Keep :: EncodingAction

-- | Change the first encoding to the second.
ChangeFromTo :: TextEncoding -> String -> EncodingAction

-- | Pure version of <a>chooseBestEnc</a>.
--   
--   This function is not actually used in the library. It exists only for
--   documentation purposes to demonstrate the logic. It is also used in
--   tests to verify that the logic implemented is indeed this.
chooseBestEncPure :: Bool -> Maybe String -> Maybe String

-- | Choose the best encoding for a file handle.
--   
--   This function implements the same logic as <a>chooseBestEncPure</a>,
--   but in a way that is more optimal in terms of IO queries. In
--   particular:
--   
--   <ol>
--   <li>It receives both a handle and its current encoding, because the
--   calling function will, most likely, need to know the current encoding
--   (e.g. to be able to restore it), so we avoid repeating the query.</li>
--   <li>It first checks for the cases where it doesn't care whether the
--   device is a terminal or not, so the query will be made only if really
--   necessary.</li>
--   </ol>
chooseBestEnc :: Handle -> (Handle -> IO Bool) -> Maybe TextEncoding -> IO EncodingAction


-- | Standard IO functions assume that the character encoding of the data
--   they read or write is the same as the one used by the current locale.
--   In many situtations this assumption is wrong, as tools work with
--   files, and files nowadays are mostly UTF-8 encoded, regardless of the
--   locale. Therefore, it is almost always a good idea to switch the
--   encoding of file handles to UTF-8.
--   
--   The same applies to standard input, output, and error handles.
--   However, there is an edge-case: if they are attached to a terminal,
--   and the current locale encoding is not UTF-8, using UTF-8 might
--   actually be unsafe.
--   
--   If you are developing an executable, in most cases, it is enough to
--   configure the environment accordingly on program start, see the
--   <a>Main.Utf8</a> for functions that help with this. However, if you
--   are a library author, you should avoid modifying the global
--   environment.
--   
--   <h1>Quick start</h1>
--   
--   <h2>Opening new files</h2>
--   
--   If you need to open a text file, use <tt>Utf8.</tt><a>withFile</a> (or
--   <tt>Utf8.</tt><a>openFile</a>). These will not only open the file, but
--   also set the handle’s encoding to UTF-8, regardless of the user’s
--   locale.
--   
--   <h2>Working with existing handles</h2>
--   
--   Suppose you are creating a function which produces some text and
--   writes it to a file handle that is passed to it from the outside. Ask
--   yourself this question: do I want to encode this text in UTF-8 or
--   using the encoding from the user’s locale?
--   
--   In many cases this question is easy to answer. For example, if your
--   function produces Haskell code, then you always want it in UTF-8,
--   because that is what all other tools (including GHC) expect.
--   
--   In some cases it is not that clear. What you can do then is consider
--   what the user is going to do with the data produced. If it is,
--   primarily, meant to be displayed on their screen and then forgotten,
--   you don’t need UTF-8. On the other hand, if it is meant to be saved
--   somewhere and then used or edited by other tools, then you need UTF-8.
--   
--   If you decided that your function needs to try to switch the handle to
--   UTF-8, it is very easy to achieve:
--   
--   <pre>
--   import qualified System.IO.Utf8 as Utf8
--   
--   writeData :: <a>Handle</a> -&gt; InputDataType -&gt; IO ()
--   writeData hOut inData = Utf8.<a>withHandle</a> hOut $ do
--     {- ... write the data ...  -}
--   </pre>
--   
--   If you decided that you don’t need to try to switch it to UTF-8,
--   replace <tt>withHandle</tt> with <a>withTerminalHandle</a> to only
--   make the handle safe to write to without runtime errors.
module System.IO.Utf8

-- | Temporarily set handle encoding to the best possible.
--   
--   “Best possible” means UTF-8, unless the handle points to a terminal
--   device, in which case the encoding will be left the same, but tweaked
--   to approximate unencodable characters.
--   
--   This function is safe to call on handles open in binary mode and it
--   will do nothing on them.
--   
--   To sum up:
--   
--   <ul>
--   <li>If the handle is in binary mode, do nothing.</li>
--   <li>If the handle points to a terminal device, act like
--   <a>withTerminalHandle</a>.</li>
--   <li>For regular files always choose UTF-8, of course.</li>
--   </ul>
withHandle :: (MonadIO m, MonadMask m) => Handle -> m r -> m r

-- | Temporarily make a handle safe to write any text to.
--   
--   If the handle is not using UTF-8, adjust the encoding to remain the
--   same as before, but approximate unencodable characters. When the
--   action is done, restore it back to the previous one.
--   
--   Use this function only if you are sure you want to treat this handle
--   as a terminal (that is, you will be using it to interact with the user
--   and to write user-visible messages, rather than something that can be
--   reasonably expected to go to a file).
--   
--   This function is safe to call on handles open in binary mode and it
--   will do nothing on them.
withTerminalHandle :: (MonadIO m, MonadMask m) => Handle -> m r -> m r

-- | Set handle encoding to the best possible.
--   
--   See <a>withHandle</a> for description and prefer it, if possible.
setHandleEncoding :: MonadIO m => Handle -> m ()

-- | Make a handle safe to write any text to.
--   
--   See <a>withTerminalHandle</a> for description and prefer it, if
--   possible.
setTerminalHandleEncoding :: MonadIO m => Handle -> m ()

-- | Like <a>openFile</a>, but sets the file encoding to UTF-8, regardless
--   of the current locale.
openFile :: MonadIO m => FilePath -> IOMode -> m Handle

-- | Like <a>withFile</a>, but sets the file encoding to UTF-8, regardless
--   of the current locale.
withFile :: (MonadIO m, MonadMask m) => FilePath -> IOMode -> (Handle -> m r) -> m r


-- | Functions in this module will help you make your <i>executable</i>
--   work correctly with encodings of text files and standard handles.
--   
--   <i>Note: if you are developing a library, see
--   <a>System.IO.Utf8</a>.</i>
--   
--   <h1>Quick start</h1>
--   
--   Wrap a call to <a>withUtf8</a> around your <tt>main</tt>:
--   
--   <pre>
--   import Main.Utf8 (withUtf8)
--   
--   main :: IO ()
--   main = <a>withUtf8</a> $ do
--     putStrLn "Hello, мир!"
--   </pre>
--   
--   Basically, this is all you have to do for a program that uses
--   <tt>stdin</tt> and <tt>stdout</tt> to interact with the user. However,
--   some programs read input from and write output to files and, at the
--   same time, allow the user to redirect <tt>stdin</tt> and
--   <tt>stdout</tt> instead of providing explicit file names.
--   
--   If this is the case for your executable, you should also wrap
--   <tt>Utf8.</tt><a>withHandle</a> around the code that passes the handle
--   to a third-party library. It is not necessary to do when passing it to
--   your own library, assuming that it follows the recommendations from
--   the documentation of <a>System.IO.Utf8</a>.
module Main.Utf8

-- | Make standard handles safe to write anything to them and change
--   program-global default file handle encoding to UTF-8.
--   
--   This function will:
--   
--   <ol>
--   <li>Adjust the encoding of <a>stdin</a>, <a>stdout</a>, and
--   <a>stderr</a> to enable transliteration, like
--   <a>withStdTerminalHandles</a> does.</li>
--   <li>Call <a>setLocaleEncoding</a> to change the program-global locale
--   encoding to UTF-8.</li>
--   <li>Undo everything when the wrapped action finishes.</li>
--   </ol>
withUtf8 :: (MonadIO m, MonadMask m) => m r -> m r

-- | Make standard handles safe to write anything to them.
--   
--   This function will for each of <a>stdin</a>, <a>stdout</a>,
--   <a>stderr</a> do:
--   
--   <ol>
--   <li>Tweak the existing encoding so that unrepresentable characters
--   will get approximated (aka transliterated) by visually similar ones or
--   question marks.</li>
--   <li>Restore the original encoding when the wrapped action
--   finishes.</li>
--   </ol>
--   
--   Use this function only if you do not want to change the program-global
--   locale encoding. Otherwise prefer <a>withUtf8</a>.
withStdTerminalHandles :: (MonadIO m, MonadMask m) => m r -> m r


-- | <a>Data.Text.Lazy.IO</a> for the modern world.
--   
--   Wrappers around simple file reading/writing functions from the
--   <tt>text</tt> package that reset the handle encoding to UTF-8.
module Data.Text.Lazy.IO.Utf8

-- | Like <tt>readFile</tt>, but assumes the file is encoded in UTF-8,
--   regardless of the current locale.
readFile :: MonadIO m => FilePath -> m Text

-- | Like <tt>writeFile</tt>, but encodes the data in UTF-8, regardless of
--   the current locale.
writeFile :: (MonadIO m, MonadMask m) => FilePath -> Text -> m ()


-- | <a>Data.Text.IO</a> for the modern world.
--   
--   Wrappers around simple file reading/writing functions from the
--   <tt>text</tt> package that reset the handle encoding to UTF-8.
module Data.Text.IO.Utf8

-- | Like <a>readFile</a>, but assumes the file is encoded in UTF-8,
--   regardless of the current locale.
readFile :: MonadIO m => FilePath -> m Text

-- | Like <a>writeFile</a>, but encodes the data in UTF-8, regardless of
--   the current locale.
writeFile :: (MonadIO m, MonadMask m) => FilePath -> Text -> m ()
