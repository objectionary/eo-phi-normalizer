-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Quasiquotations for a python like interpolated string formatter
--   
--   Quasiquotations for a python like interpolated string formatter.
@package PyF
@version 0.11.2.1


-- | Formatters for integral / fractional and strings.
--   
--   Is support:
--   
--   For all types:
--   
--   <ul>
--   <li>Grouping of the integral part (i.e: adding a custom char to
--   separate groups of digits)</li>
--   <li>Padding (left, right, around, and between the sign and the
--   number)</li>
--   <li>Sign handling (i.e: display the positive sign or not)</li>
--   </ul>
--   
--   For floating:
--   
--   <ul>
--   <li>Precision</li>
--   <li>Fixed <i> Exponential </i> Generic formatting</li>
--   </ul>
--   
--   For integrals:
--   
--   <ul>
--   <li>Binary <i> Hexa </i> Octal / Character representation</li>
--   </ul>
module PyF.Formatters

-- | Format a string
formatString :: forall paddingWidth precision. (Integral paddingWidth, Integral precision) => Maybe (paddingWidth, AlignMode 'AlignAll, Char) -> Maybe precision -> String -> String

-- | Format an integral number
formatIntegral :: Integral paddingWidth => Integral i => Format t t' 'Integral -> SignMode -> Maybe (paddingWidth, AlignMode k, Char) -> Maybe (Int, Char) -> i -> String

-- | Format a fractional number
formatFractional :: (RealFloat f, Integral paddingWidth, Integral precision) => Format t t' 'Fractional -> SignMode -> Maybe (paddingWidth, AlignMode k, Char) -> Maybe (Int, Char) -> Maybe precision -> f -> String

-- | This formatter support alternate version
data AltStatus
CanAlt :: AltStatus
NoAlt :: AltStatus

-- | This formatter support Upper case version
data UpperStatus
CanUpper :: UpperStatus
NoUpper :: UpperStatus

-- | This formatter formats an integral or a fractional
data FormatType
Fractional :: FormatType
Integral :: FormatType

-- | All the Formatters
data Format (k :: AltStatus) (k' :: UpperStatus) (k'' :: FormatType)
[Decimal] :: Format 'NoAlt 'NoUpper 'Integral
[Character] :: Format 'NoAlt 'NoUpper 'Integral
[Binary] :: Format 'CanAlt 'NoUpper 'Integral
[Hexa] :: Format 'CanAlt 'CanUpper 'Integral
[Octal] :: Format 'CanAlt 'NoUpper 'Integral
[Fixed] :: Format 'CanAlt 'CanUpper 'Fractional
[Exponent] :: Format 'CanAlt 'CanUpper 'Fractional
[Generic] :: Format 'CanAlt 'CanUpper 'Fractional
[Percent] :: Format 'CanAlt 'NoUpper 'Fractional
[Alternate] :: Format 'CanAlt u f -> Format 'NoAlt u f
[Upper] :: Format alt 'CanUpper f -> Format 'NoAlt 'NoUpper f

-- | Sign handling
data SignMode

-- | Display <a>-</a> sign and <a>+</a> sign
Plus :: SignMode

-- | Only display <a>-</a> sign
Minus :: SignMode

-- | Display <a>-</a> sign and a space for positive numbers
Space :: SignMode

-- | Existential version of <a>AlignMode</a>
data AnyAlign
[AnyAlign] :: AlignMode (k :: AlignForString) -> AnyAlign

-- | Alignement
data AlignMode (k :: AlignForString)

-- | Left padding
[AlignLeft] :: AlignMode 'AlignAll

-- | Right padding
[AlignRight] :: AlignMode 'AlignAll

-- | Padding will be added between the sign and the number
[AlignInside] :: AlignMode 'AlignNumber

-- | Padding will be added around the value
[AlignCenter] :: AlignMode 'AlignAll
getAlignForString :: AlignMode k -> Maybe (AlignMode 'AlignAll)
data AlignForString
AlignAll :: AlignForString
AlignNumber :: AlignForString
instance Data.Data.Data PyF.Formatters.SignMode
instance GHC.Show.Show PyF.Formatters.SignMode
instance GHC.Show.Show PyF.Formatters.AlignForString
instance GHC.Real.Integral i => GHC.Real.Integral (PyF.Formatters.ShowIntegral i)
instance GHC.Num.Num i => GHC.Num.Num (PyF.Formatters.ShowIntegral i)
instance GHC.Classes.Eq i => GHC.Classes.Eq (PyF.Formatters.ShowIntegral i)
instance GHC.Classes.Ord i => GHC.Classes.Ord (PyF.Formatters.ShowIntegral i)
instance GHC.Enum.Enum i => GHC.Enum.Enum (PyF.Formatters.ShowIntegral i)
instance GHC.Real.Real i => GHC.Real.Real (PyF.Formatters.ShowIntegral i)
instance GHC.Show.Show PyF.Formatters.Sign
instance GHC.Show.Show PyF.Formatters.Repr
instance GHC.Show.Show (PyF.Formatters.AlignMode k)
instance GHC.Show.Show PyF.Formatters.AnyAlign
instance Language.Haskell.TH.Syntax.Lift PyF.Formatters.AnyAlign
instance Language.Haskell.TH.Syntax.Lift (PyF.Formatters.AlignMode k)
instance Language.Haskell.TH.Syntax.Lift PyF.Formatters.SignMode
instance Language.Haskell.TH.Syntax.Lift (PyF.Formatters.Format k k' k'')
instance GHC.Show.Show (PyF.Formatters.ShowIntegral i)


-- | You want to add formatting support for your custom type. This is the
--   right module.
--   
--   In PyF, formatters are in three categories:
--   
--   <ul>
--   <li>Integral numbers, which are numbers without fractional part</li>
--   <li>Fractional numbers, which are numbers with a fractional part</li>
--   <li>String, which represents text.</li>
--   </ul>
--   
--   The formatting can be either explicit or implicit. For example:
--   
--   <pre>
--   &gt;&gt;&gt; let x = 10 in [fmt|{x}|]
--   10
--   </pre>
--   
--   Is an implicit formatting to number, but:
--   
--   <pre>
--   &gt;&gt;&gt; let x = 10 in [fmt|{x:d}|]
--   </pre>
--   
--   Is an explicit formatting to Integral numbers, using <tt>d</tt>.
--   
--   Implicit formatting will only format to either Integral, Fractional or
--   text, and this choice is done by the (open) type family
--   <a>PyFCategory</a>.
--   
--   This modules also provides 3 type class for formatting.
--   
--   <ul>
--   <li><a>PyfFormatFractional</a> and <a>PyfFormatIntegral</a> are
--   responsible for formatting integral and fractional numbers. Default
--   instances are provided respectively for <a>Real</a> and
--   <a>FormatType</a>. <a>PyFToString</a> is in charge of formatting
--   text.</li>
--   </ul>
module PyF.Class

-- | The three categories of formatting in <tt>PyF</tt>
data PyFCategory

-- | Format as an integral, no fractional part, precise value
PyFIntegral :: PyFCategory

-- | Format as a fractional, approximate value with a fractional part
PyFFractional :: PyFCategory

-- | Format as a string
PyFString :: PyFCategory

-- | Classify a type to a <a>PyFCategory</a> This classification will be
--   used to decide which formatting to use when no type specifier in
--   provided.
type family PyFClassify t :: PyFCategory

-- | Convert a type to string This is used for the string formatting.
class PyFToString t
pyfToString :: PyFToString t => t -> String

-- | Apply a fractional formatting to any type.
--   
--   A default instance for any <a>Real</a> is provided which internally
--   converts to <a>Double</a>, which may not be efficient or results in
--   rounding errors.
--   
--   You can provide your own instance and internally use
--   <a>formatFractional</a> which does have the same signatures as
--   <a>pyfFormatFractional</a> but with a <a>RealFrac</a> constraint.
class PyfFormatFractional a
pyfFormatFractional :: (PyfFormatFractional a, Integral paddingWidth, Integral precision) => Format t t' 'Fractional -> SignMode -> Maybe (paddingWidth, AlignMode k, Char) -> Maybe (Int, Char) -> Maybe precision -> a -> String

-- | Apply an integral formatting to any type.
--   
--   A default instance for any <a>FormatType</a> is provided.
--   
--   You can provide your own instance and internally use
--   <a>formatIntegral</a> which does have the same signatures as
--   <a>pyfFormatIntegral</a> but with an <a>FormatType</a> constraint.
class PyfFormatIntegral i
pyfFormatIntegral :: (PyfFormatIntegral i, Integral paddingWidth) => Format t t' 'Integral -> SignMode -> Maybe (paddingWidth, AlignMode k, Char) -> Maybe (Int, Char) -> i -> String
instance GHC.Real.Integral t => PyF.Class.PyfFormatIntegral t
instance PyF.Class.PyfFormatIntegral GHC.Types.Char
instance GHC.Real.Real t => PyF.Class.PyfFormatFractional t
instance PyF.Class.PyfFormatFractional GHC.Types.Double
instance PyF.Class.PyfFormatFractional GHC.Types.Float
instance PyF.Class.PyFToString GHC.Base.String
instance PyF.Class.PyFToString Data.Text.Internal.Lazy.Text
instance PyF.Class.PyFToString Data.Text.Internal.Text
instance PyF.Class.PyFToString Data.ByteString.Internal.Type.ByteString
instance PyF.Class.PyFToString Data.ByteString.Lazy.Internal.ByteString
instance PyF.Class.PyFToString GHC.Types.Char
instance GHC.Show.Show t => PyF.Class.PyFToString t

module PyF.Internal.ParserEx
fakeSettings :: Settings
fakeLlvmConfig :: LlvmConfig
parseExpression :: RealSrcLoc -> String -> DynFlags -> ParseResult (LocatedA (HsExpr GhcPs))


-- | This module is here to parse Haskell expression using the GHC Api
module PyF.Internal.Parser
parseExpression :: RealSrcLoc -> String -> DynFlags -> Either (Int, Int, String) (HsExpr GhcPs)

module PyF.Internal.Meta
toExp :: DynFlags -> HsExpr GhcPs -> Exp
baseDynFlags :: [Extension] -> DynFlags
toName :: RdrName -> Name


-- | This module provides a parser for <a>python format string mini
--   language</a>.
module PyF.Internal.PythonSyntax

-- | Parse a string, returns a list of raw string or replacement fields
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Megaparsec
--   
--   &gt;&gt;&gt; parse parsePythonFormatString "" "hello {1+1:&gt;10.2f}"
--   Right [
--          Raw "hello ",
--          Replacement "1+1"
--          (
--          Just (FormatMode
--                         (Padding 10 (Just (Nothing,AnyAlign AlignRight)))
--                         (FixedF (Precision 2) NormalForm Minus)
--                          Nothing))]
--   </pre>
parseGenericFormatString :: Parser [Item]

-- | A format string is composed of many chunks of raw string or
--   replacement
data Item

-- | A raw string
Raw :: String -> Item

-- | A replacement string, composed of an arbitrary Haskell expression
--   followed by an optional formatter
Replacement :: (HsExpr GhcPs, Exp) -> Maybe FormatMode -> Item

-- | A Formatter, listing padding, format and and grouping char
data FormatMode
FormatMode :: Padding -> TypeFormat -> Maybe Char -> FormatMode

-- | Padding, containing the padding width, the padding char and the
--   alignement mode
data Padding
PaddingDefault :: Padding
Padding :: ExprOrValue Int -> Maybe (Maybe Char, AnyAlign) -> Padding

-- | Floating point precision
data Precision
PrecisionDefault :: Precision
Precision :: ExprOrValue Int -> Precision

-- | All formatting type
data TypeFormat

-- | Default, depends on the infered type of the expression
DefaultF :: Precision -> SignMode -> TypeFormat

-- | Binary, such as `0b0121`
BinaryF :: AlternateForm -> SignMode -> TypeFormat

-- | Character, will convert an integer to its character representation
CharacterF :: TypeFormat

-- | Decimal, base 10 integer formatting
DecimalF :: SignMode -> TypeFormat

-- | Exponential notation for floatting points
ExponentialF :: Precision -> AlternateForm -> SignMode -> TypeFormat

-- | Exponential notation with capitalised <tt>e</tt>
ExponentialCapsF :: Precision -> AlternateForm -> SignMode -> TypeFormat

-- | Fixed number of digits floating point
FixedF :: Precision -> AlternateForm -> SignMode -> TypeFormat

-- | Capitalized version of the previous
FixedCapsF :: Precision -> AlternateForm -> SignMode -> TypeFormat

-- | General formatting: <a>FixedF</a> or <a>ExponentialF</a> depending on
--   the number magnitude
GeneralF :: Precision -> AlternateForm -> SignMode -> TypeFormat

-- | Same as <a>GeneralF</a> but with upper case <tt>E</tt> and infinite /
--   NaN
GeneralCapsF :: Precision -> AlternateForm -> SignMode -> TypeFormat

-- | Octal, such as 00245
OctalF :: AlternateForm -> SignMode -> TypeFormat

-- | Simple string
StringF :: Precision -> TypeFormat

-- | Hexadecimal, such as 0xaf3e
HexF :: AlternateForm -> SignMode -> TypeFormat

-- | Hexadecimal with capitalized letters, such as 0XAF3E
HexCapsF :: AlternateForm -> SignMode -> TypeFormat

-- | Percent representation
PercentF :: Precision -> AlternateForm -> SignMode -> TypeFormat

-- | If the formatter use its alternate form
data AlternateForm
AlternateForm :: AlternateForm
NormalForm :: AlternateForm

-- | Default formatting mode, no padding, default precision, no grouping,
--   no sign handling
pattern DefaultFormatMode :: FormatMode
type Parser t = ParsecT String () (Reader ParsingContext) t
data ParsingContext
ParsingContext :: Maybe (Char, Char) -> [Extension] -> ParsingContext
[delimiters] :: ParsingContext -> Maybe (Char, Char)
[enabledExtensions] :: ParsingContext -> [Extension]

-- | Represents a value of type <tt>t</tt> or an Haskell expression
--   supposed to represents that value
data ExprOrValue t
Value :: t -> ExprOrValue t
HaskellExpr :: (HsExpr GhcPs, Exp) -> ExprOrValue t
instance GHC.Show.Show PyF.Internal.PythonSyntax.ParsingContext
instance Data.Data.Data t => Data.Data.Data (PyF.Internal.PythonSyntax.ExprOrValue t)
instance Data.Data.Data PyF.Internal.PythonSyntax.Precision
instance GHC.Show.Show PyF.Internal.PythonSyntax.TypeFlag
instance Data.Data.Data PyF.Internal.PythonSyntax.AlternateForm
instance GHC.Show.Show PyF.Internal.PythonSyntax.AlternateForm
instance Data.Data.Data PyF.Internal.PythonSyntax.TypeFormat


-- | This module uses the python mini language detailed in
--   <a>PythonSyntax</a> to build an template haskell expression
--   representing a formatted string.
module PyF.Internal.QQ

-- | Parse a string and return a formatter for it
toExp :: Config -> String -> Q Exp

-- | Configuration for the quasiquoter
data Config
Config :: Maybe (Char, Char) -> (Q Exp -> Q Exp) -> Config

-- | What are the delimiters for interpolation. <a>Nothing</a> means no
--   interpolation / formatting.
[delimiters] :: Config -> Maybe (Char, Char)

-- | Post processing. The input <a>Exp</a> represents a <a>String</a>.
--   Common use case includes using <a>wrapFromString</a> to add
--   <a>fromString</a> in the context of <a>OverloadedStrings</a>.
[postProcess] :: Config -> Q Exp -> Q Exp

-- | If <a>OverloadedStrings</a> is enabled, from the input expression with
--   <a>fromString</a>.
wrapFromString :: ExpQ -> Q Exp

-- | Build a quasiquoter for expression
expQQ :: String -> (String -> Q Exp) -> QuasiQuoter
instance PyF.Internal.QQ.FormatAny2 (PyF.Class.PyFClassify t) t k => PyF.Internal.QQ.FormatAny t k
instance (GHC.Show.Show t, GHC.Real.Integral t) => PyF.Internal.QQ.FormatAny2 'PyF.Class.PyFIntegral t k
instance PyF.Class.PyfFormatFractional t => PyF.Internal.QQ.FormatAny2 'PyF.Class.PyFFractional t k
instance PyF.Class.PyFToString t => PyF.Internal.QQ.FormatAny2 'PyF.Class.PyFString t 'PyF.Formatters.AlignAll
instance (TypeError ...) => PyF.Internal.QQ.FormatAny2 'PyF.Class.PyFString t 'PyF.Formatters.AlignNumber


-- | A lot of quasiquoters to format and interpolate string expression
module PyF

-- | Generic formatter, can format an expression to any <tt>t</tt> as long
--   as <tt>t</tt> is an instance of <tt>IsString</tt>.
fmt :: QuasiQuoter

-- | Format with whitespace trimming.
fmtTrim :: QuasiQuoter

-- | multiline string, no interpolation.
str :: QuasiQuoter

-- | multiline string, no interpolation, but does indentation trimming.
strTrim :: QuasiQuoter

-- | Raw string, no interpolation neither escaping is performed.
raw :: QuasiQuoter

-- | Removes the trailing whitespace of a string.
--   
--   <ul>
--   <li>First line is ignored if it only contains whitespaces</li>
--   <li>All other line common indentation is removed, ignoring line with
--   only whitespaces.</li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; trimIndent "\n   hello\n   - a\n   - b\n   "
--   "hello\n- a\n- b\n"
--   </pre>
--   
--   See <a>fmtTrim</a> for a quasiquoter with this behavior
trimIndent :: String -> String

-- | Build a formatter. See the <a>Config</a> type for details, as well as
--   <a>fmtConfig</a> and <a>strConfig</a> for examples.
mkFormatter :: String -> Config -> QuasiQuoter

-- | This is an empty configuration. No formatting, no post processing
defaultConfig :: Config

-- | The config for <a>fmt</a>.
fmtConfig :: Config

-- | Configuration for <a>str</a> it just wrap the multiline string with
--   <tt>fromString</tt>.
strConfig :: Config

-- | Add indentation trimming to a configuration.
addTrim :: Config -> Config

-- | Enable formatting
addFormatting :: (Char, Char) -> Config -> Config
