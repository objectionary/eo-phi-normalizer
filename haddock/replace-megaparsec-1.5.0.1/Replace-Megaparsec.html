<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Replace.Megaparsec</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">replace-megaparsec-1.5.0.1: Find, replace, split string patterns with Megaparsec parsers (instead of regex)</span><ul class="links" id="page-menu"><li><a href="src/Replace.Megaparsec.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>&#169;2019 James Brock</td></tr><tr><th>License</th><td>BSD2</td></tr><tr><th>Maintainer</th><td>James Brock &lt;jamesbrock@gmail.com&gt;</td></tr><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Replace.Megaparsec</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Running parser</a></li><li><a href="#g:2">Parser combinator</a></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p><strong>Replace.Megaparsec</strong> is for finding text patterns, and also
 replacing or splitting on the found patterns.
 This activity is traditionally done with regular expressions,
 but <strong>Replace.Megaparsec</strong> uses <a href="../megaparsec-9.5.0/Text-Megaparsec.html">Text.Megaparsec</a> parsers instead for
 the pattern matching.</p><p><strong>Replace.Megaparsec</strong> can be used in the same sort of &#8220;pattern capture&#8221;
 or &#8220;find all&#8221; situations in which one would use Python
 <a href="https://docs.python.org/3/library/re.html#re.findall">re.findall</a>,
 or Perl
 <a href="https://perldoc.perl.org/functions/m.html">m//</a>,
 or Unix
 <a href="https://www.gnu.org/software/grep/">grep</a>.</p><p><strong>Replace.Megaparsec</strong> can be used in the same sort of &#8220;stream editing&#8221;
 or &#8220;search-and-replace&#8221; situations in which one would use Python
 <a href="https://docs.python.org/3/library/re.html#re.sub">re.sub</a>,
 or Perl
 <a href="https://perldoc.perl.org/functions/s.html">s///</a>,
 or Unix
 <a href="https://www.gnu.org/software/sed/manual/html_node/The-_0022s_0022-Command.html">sed</a>,
 or
 <a href="https://www.gnu.org/software/gawk/manual/gawk.html">awk</a>.</p><p><strong>Replace.Megaparsec</strong> can be used in the same sort of &#8220;string splitting&#8221;
 situations in which one would use Python
 <a href="https://docs.python.org/3/library/re.html#re.split">re.split</a>
 or Perl
 <a href="https://perldoc.perl.org/functions/split.html">split</a>.</p><p>See the <strong>replace-megaparsec</strong> package README for usage examples.</p><h2>Type constraints</h2><h3>output stream type <code>Tokens s</code> = input stream type <code>s</code></h3><p>All functions in the <strong>Running Parser</strong> section require the type of the
 stream of text that is input to be
 <code><code><a href="../megaparsec-9.5.0/Text-Megaparsec-Stream.html#v:Stream" title="Text.Megaparsec.Stream">Stream</a></code> s</code>
 such that
 <code><code><a href="../megaparsec-9.5.0/Text-Megaparsec-Stream.html#v:Tokens" title="Text.Megaparsec.Stream">Tokens</a></code> s ~ s</code>,
 because we want to output the same type of stream that was input.
 That requirement is satisfied for all the <code><a href="../megaparsec-9.5.0/Text-Megaparsec-Stream.html#t:Stream" title="Text.Megaparsec.Stream">Stream</a></code> instances
 included with <a href="../megaparsec-9.5.0/Text-Megaparsec.html">Text.Megaparsec</a>:</p><ul><li><a href="../base-4.18.2.0/Data-String.html">Data.String</a></li><li><a href="../text-2.0.2/Data-Text.html">Data.Text</a></li><li><a href="../text-2.0.2/Data-Text-Lazy.html">Data.Text.Lazy</a></li><li><a href="../bytestring-0.11.5.3/Data-ByteString.html">Data.ByteString</a></li><li><a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html">Data.ByteString.Lazy</a></li></ul><h3>Custom error type <code>e</code> should be <code><a href="Data.html#v:Void" title="Data">Void</a></code></h3><p>Megaparsec parsers have a custom error data component <code>e</code>. When writing parsers
 to be used by this module, the custom error type <code>e</code> should usually
 be <code><a href="Data.html#v:Void" title="Data">Void</a></code>, because every function in this module expects a parser
 failure to occur on every token in a non-matching section of the input
 stream, so parser failure error descriptions are not returned, and you'll
 never see the custom error information.</p><h2>Special fast input types</h2><p>Functions in this module will be &#8220;fast&#8221; when the input stream
 type <code>s</code> is:</p><ul><li><a href="../text-2.0.2/Data-Text.html">Data.Text</a></li><li><a href="../bytestring-0.11.5.3/Data-ByteString.html">Data.ByteString</a></li></ul><p>We mean &#8220;fast&#8221; in the same sense as <code><a href="../megaparsec-9.5.0/Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a></code>:
 when returning subsections of the input stream,
 we return slices of the input stream data, rather than constructing a list
 of tokens and then building a new stream subsection from that list.
 This relies on implementation details of the stream representation,
 so there are specialization re-write rules in this module to make
 that possible without adding new typeclasses.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:breakCap">breakCap</a> :: <span class="keyword">forall</span> e s a. (<a href="../base-4.18.2.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> e, <a href="../megaparsec-9.5.0/Text-Megaparsec-Stream.html#t:Stream" title="Text.Megaparsec.Stream">Stream</a> s, <a href="../megaparsec-9.5.0/Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s <a href="../base-4.18.2.0/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> s) =&gt; <a href="../megaparsec-9.5.0/Text-Megaparsec.html#t:Parsec" title="Text.Megaparsec">Parsec</a> e s a -&gt; s -&gt; <a href="../base-4.18.2.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (s, a, s)</li><li class="src short"><a href="#v:breakCapT">breakCapT</a> :: <span class="keyword">forall</span> m e s a. (<a href="../base-4.18.2.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> e, <a href="../megaparsec-9.5.0/Text-Megaparsec-Stream.html#t:Stream" title="Text.Megaparsec.Stream">Stream</a> s, <a href="../megaparsec-9.5.0/Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s <a href="../base-4.18.2.0/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> s, <a href="../base-4.18.2.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="../megaparsec-9.5.0/Text-Megaparsec-Internal.html#t:ParsecT" title="Text.Megaparsec.Internal">ParsecT</a> e s m a -&gt; s -&gt; m (<a href="../base-4.18.2.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (s, a, s))</li><li class="src short"><a href="#v:splitCap">splitCap</a> :: <span class="keyword">forall</span> e s a. (<a href="../base-4.18.2.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> e, <a href="../megaparsec-9.5.0/Text-Megaparsec-Stream.html#t:Stream" title="Text.Megaparsec.Stream">Stream</a> s, <a href="../megaparsec-9.5.0/Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s <a href="../base-4.18.2.0/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> s) =&gt; <a href="../megaparsec-9.5.0/Text-Megaparsec.html#t:Parsec" title="Text.Megaparsec">Parsec</a> e s a -&gt; s -&gt; [<a href="../base-4.18.2.0/Data-Either.html#t:Either" title="Data.Either">Either</a> s a]</li><li class="src short"><a href="#v:splitCapT">splitCapT</a> :: <span class="keyword">forall</span> e s m a. (<a href="../base-4.18.2.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> e, <a href="../megaparsec-9.5.0/Text-Megaparsec-Stream.html#t:Stream" title="Text.Megaparsec.Stream">Stream</a> s, <a href="../megaparsec-9.5.0/Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s <a href="../base-4.18.2.0/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> s, <a href="../base-4.18.2.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="../megaparsec-9.5.0/Text-Megaparsec-Internal.html#t:ParsecT" title="Text.Megaparsec.Internal">ParsecT</a> e s m a -&gt; s -&gt; m [<a href="../base-4.18.2.0/Data-Either.html#t:Either" title="Data.Either">Either</a> s a]</li><li class="src short"><a href="#v:streamEdit">streamEdit</a> :: <span class="keyword">forall</span> e s a. (<a href="../base-4.18.2.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> e, <a href="../megaparsec-9.5.0/Text-Megaparsec-Stream.html#t:Stream" title="Text.Megaparsec.Stream">Stream</a> s, <a href="../base-4.18.2.0/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> s, <a href="../megaparsec-9.5.0/Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s <a href="../base-4.18.2.0/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> s) =&gt; <a href="../megaparsec-9.5.0/Text-Megaparsec.html#t:Parsec" title="Text.Megaparsec">Parsec</a> e s a -&gt; (a -&gt; s) -&gt; s -&gt; s</li><li class="src short"><a href="#v:streamEditT">streamEditT</a> :: <span class="keyword">forall</span> e s m a. (<a href="../base-4.18.2.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> e, <a href="../megaparsec-9.5.0/Text-Megaparsec-Stream.html#t:Stream" title="Text.Megaparsec.Stream">Stream</a> s, <a href="../base-4.18.2.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="../base-4.18.2.0/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> s, <a href="../megaparsec-9.5.0/Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s <a href="../base-4.18.2.0/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> s) =&gt; <a href="../megaparsec-9.5.0/Text-Megaparsec-Internal.html#t:ParsecT" title="Text.Megaparsec.Internal">ParsecT</a> e s m a -&gt; (a -&gt; m s) -&gt; s -&gt; m s</li><li class="src short"><a href="#v:anyTill">anyTill</a> :: <span class="keyword">forall</span> e s m a. <a href="../megaparsec-9.5.0/Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m =&gt; m a -&gt; m (<a href="../megaparsec-9.5.0/Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s, a)</li><li class="src short"><a href="#v:sepCap">sepCap</a> :: <span class="keyword">forall</span> e s m a. <a href="../megaparsec-9.5.0/Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m =&gt; m a -&gt; m [<a href="../base-4.18.2.0/Data-Either.html#t:Either" title="Data.Either">Either</a> (<a href="../megaparsec-9.5.0/Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s) a]</li><li class="src short"><a href="#v:findAll">findAll</a> :: <a href="../megaparsec-9.5.0/Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m =&gt; m a -&gt; m [<a href="../base-4.18.2.0/Data-Either.html#t:Either" title="Data.Either">Either</a> (<a href="../megaparsec-9.5.0/Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s) (<a href="../megaparsec-9.5.0/Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s)]</li><li class="src short"><a href="#v:findAllCap">findAllCap</a> :: <a href="../megaparsec-9.5.0/Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m =&gt; m a -&gt; m [<a href="../base-4.18.2.0/Data-Either.html#t:Either" title="Data.Either">Either</a> (<a href="../megaparsec-9.5.0/Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s) (<a href="../megaparsec-9.5.0/Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s, a)]</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Running parser</h1></a><div class="doc"><p>Functions in this section are <em>ways to run parsers</em>
 (like <code><a href="../megaparsec-9.5.0/Text-Megaparsec.html#v:runParser" title="Text.Megaparsec">runParser</a></code>). They take
 as arguments a <code>sep</code> parser and some input, run the parser on the input,
 and return a result.</p></div><div class="top"><p class="src"><a id="v:breakCap" class="def">breakCap</a> <a href="src/Replace.Megaparsec.html#breakCap" class="link">Source</a> <a href="#v:breakCap" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <span class="keyword">forall</span> e s a. (<a href="../base-4.18.2.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> e, <a href="../megaparsec-9.5.0/Text-Megaparsec-Stream.html#t:Stream" title="Text.Megaparsec.Stream">Stream</a> s, <a href="../megaparsec-9.5.0/Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s <a href="../base-4.18.2.0/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> s)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="../megaparsec-9.5.0/Text-Megaparsec.html#t:Parsec" title="Text.Megaparsec">Parsec</a> e s a</td><td class="doc"><p>The pattern matching parser <code>sep</code></p></td></tr><tr><td class="src">-&gt; s</td><td class="doc"><p>The input stream of text</p></td></tr><tr><td class="src">-&gt; <a href="../base-4.18.2.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (s, a, s)</td><td class="doc"><p>Maybe (prefix, parse_result, suffix)</p></td></tr></table></div><div class="doc"><h3>Break on and capture one pattern</h3><p>Find the first occurence of a pattern in a text stream, capture the found
 pattern, and break the input text stream on the found pattern.</p><p>The <code><a href="Replace-Megaparsec.html#v:breakCap" title="Replace.Megaparsec">breakCap</a></code> function is like <code><a href="../base-4.18.2.0/Data-List.html#v:takeWhile" title="Data.List">takeWhile</a></code>, but can be predicated
 beyond more than just the next one token. It's also like <code><a href="../text-2.0.2/Data-Text.html#v:breakOn" title="Data.Text">breakOn</a></code>,
 but the <code>needle</code> can be a pattern instead of a constant string.</p><p>Be careful not to look too far
 ahead; if the <code>sep</code> parser looks to the end of the input then <code><a href="Replace-Megaparsec.html#v:breakCap" title="Replace.Megaparsec">breakCap</a></code>
 could be <em>O(n&#178;)</em>.</p><p>The pattern parser <code>sep</code> may match a zero-width pattern (a pattern which
 consumes no parser input on success).</p><h4>Output</h4><ul><li><code>Nothing</code> when no pattern match was found.</li><li><code>Just (prefix, parse_result, suffix)</code> for the result of parsing the
    pattern match, and the <code>prefix</code> string before and the <code>suffix</code> string
    after the pattern match. <code>prefix</code> and <code>suffix</code> may be zero-length strings.</li></ul><h4>Access the matched section of text</h4><p>If you want to capture the matched string, then combine the pattern
 parser <code>sep</code> with <code><a href="../megaparsec-9.5.0/Text-Megaparsec.html#v:match" title="Text.Megaparsec">match</a></code>.</p><p>With the matched string, we can reconstruct the input string.
 For all <code>input</code>, <code>sep</code>, if</p><pre>let (<code><a href="../base-4.18.2.0/Data-Maybe.html#v:Just" title="Data.Maybe">Just</a></code> (prefix, (infix, _), suffix)) = breakCap (<code><a href="../megaparsec-9.5.0/Text-Megaparsec.html#v:match" title="Text.Megaparsec">match</a></code> sep) input
</pre><p>then</p><pre>input == prefix <code><a href="../base-4.18.2.0/Data-Monoid.html#v:-60--62-" title="Data.Monoid">&lt;&gt;</a></code> infix <code><a href="../base-4.18.2.0/Data-Monoid.html#v:-60--62-" title="Data.Monoid">&lt;&gt;</a></code> suffix
</pre></div></div><div class="top"><p class="src"><a id="v:breakCapT" class="def">breakCapT</a> <a href="src/Replace.Megaparsec.html#breakCapT" class="link">Source</a> <a href="#v:breakCapT" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <span class="keyword">forall</span> m e s a. (<a href="../base-4.18.2.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> e, <a href="../megaparsec-9.5.0/Text-Megaparsec-Stream.html#t:Stream" title="Text.Megaparsec.Stream">Stream</a> s, <a href="../megaparsec-9.5.0/Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s <a href="../base-4.18.2.0/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> s, <a href="../base-4.18.2.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="../megaparsec-9.5.0/Text-Megaparsec-Internal.html#t:ParsecT" title="Text.Megaparsec.Internal">ParsecT</a> e s m a</td><td class="doc"><p>The pattern matching parser <code>sep</code></p></td></tr><tr><td class="src">-&gt; s</td><td class="doc"><p>The input stream of text</p></td></tr><tr><td class="src">-&gt; m (<a href="../base-4.18.2.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (s, a, s))</td><td class="doc"><p>Maybe (prefix, parse_result, suffix)</p></td></tr></table></div><div class="doc"><h3>Break on and capture one pattern</h3><p>Monad transformer version of <code><a href="Replace-Megaparsec.html#v:breakCap" title="Replace.Megaparsec">breakCap</a></code>.</p><p>The parser <code>sep</code> will run in the underlying monad context.</p></div></div><div class="top"><p class="src"><a id="v:splitCap" class="def">splitCap</a> <a href="src/Replace.Megaparsec.html#splitCap" class="link">Source</a> <a href="#v:splitCap" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <span class="keyword">forall</span> e s a. (<a href="../base-4.18.2.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> e, <a href="../megaparsec-9.5.0/Text-Megaparsec-Stream.html#t:Stream" title="Text.Megaparsec.Stream">Stream</a> s, <a href="../megaparsec-9.5.0/Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s <a href="../base-4.18.2.0/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> s)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="../megaparsec-9.5.0/Text-Megaparsec.html#t:Parsec" title="Text.Megaparsec">Parsec</a> e s a</td><td class="doc"><p>The pattern matching parser <code>sep</code></p></td></tr><tr><td class="src">-&gt; s</td><td class="doc"><p>The input stream of text</p></td></tr><tr><td class="src">-&gt; [<a href="../base-4.18.2.0/Data-Either.html#t:Either" title="Data.Either">Either</a> s a]</td><td class="doc"><p>List of matching and non-matching input sections.</p></td></tr></table></div><div class="doc"><h3>Split on and capture all patterns</h3><p>Find all occurences of the pattern <code>sep</code>, split the input string, capture
 all the patterns and the splits.</p><p>The input string will be split on every leftmost non-overlapping occurence
 of the pattern <code>sep</code>. The output list will contain
 the parsed result of input string sections which match the <code>sep</code> pattern
 in <code><a href="../base-4.18.2.0/Data-Either.html#v:Right" title="Data.Either">Right</a></code>, and non-matching sections in <code><a href="../base-4.18.2.0/Data-Either.html#v:Left" title="Data.Either">Left</a></code>.</p><p><code><a href="Replace-Megaparsec.html#v:splitCap" title="Replace.Megaparsec">splitCap</a></code> depends on <code><a href="Replace-Megaparsec.html#v:sepCap" title="Replace.Megaparsec">sepCap</a></code>, see <code><a href="Replace-Megaparsec.html#v:sepCap" title="Replace.Megaparsec">sepCap</a></code> for more details.</p><h4>Access the matched section of text</h4><p>If you want to capture the matched strings, then combine the pattern
 parser <code>sep</code> with <code><a href="../megaparsec-9.5.0/Text-Megaparsec.html#v:match" title="Text.Megaparsec">match</a></code>.</p><p>With the matched strings, we can reconstruct the input string.
 For all <code>input</code>, <code>sep</code>, if</p><pre>let output = splitCap (<code><a href="../megaparsec-9.5.0/Text-Megaparsec.html#v:match" title="Text.Megaparsec">match</a></code> sep) input
</pre><p>then</p><pre>input == <code><a href="../base-4.18.2.0/Data-Monoid.html#v:mconcat" title="Data.Monoid">mconcat</a></code> (<code><a href="../base-4.18.2.0/Data-Bifunctor.html#v:second" title="Data.Bifunctor">second</a></code> <code><a href="../base-4.18.2.0/Data-Tuple.html#v:fst" title="Data.Tuple">fst</a></code> <code><a href="../base-4.18.2.0/Data-Functor.html#v:-60--36--62-" title="Data.Functor">&lt;$&gt;</a></code> output)
</pre></div></div><div class="top"><p class="src"><a id="v:splitCapT" class="def">splitCapT</a> <a href="src/Replace.Megaparsec.html#splitCapT" class="link">Source</a> <a href="#v:splitCapT" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <span class="keyword">forall</span> e s m a. (<a href="../base-4.18.2.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> e, <a href="../megaparsec-9.5.0/Text-Megaparsec-Stream.html#t:Stream" title="Text.Megaparsec.Stream">Stream</a> s, <a href="../megaparsec-9.5.0/Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s <a href="../base-4.18.2.0/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> s, <a href="../base-4.18.2.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="../megaparsec-9.5.0/Text-Megaparsec-Internal.html#t:ParsecT" title="Text.Megaparsec.Internal">ParsecT</a> e s m a</td><td class="doc"><p>The pattern matching parser <code>sep</code></p></td></tr><tr><td class="src">-&gt; s</td><td class="doc"><p>The input stream of text</p></td></tr><tr><td class="src">-&gt; m [<a href="../base-4.18.2.0/Data-Either.html#t:Either" title="Data.Either">Either</a> s a]</td><td class="doc"><p>List of matching and non-matching input sections.</p></td></tr></table></div><div class="doc"><h3>Split on and capture all patterns</h3><p>Monad transformer version of <code><a href="Replace-Megaparsec.html#v:splitCap" title="Replace.Megaparsec">splitCap</a></code>.</p><p>The parser <code>sep</code> will run in the underlying monad context.</p></div></div><div class="top"><p class="src"><a id="v:streamEdit" class="def">streamEdit</a> <a href="src/Replace.Megaparsec.html#streamEdit" class="link">Source</a> <a href="#v:streamEdit" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <span class="keyword">forall</span> e s a. (<a href="../base-4.18.2.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> e, <a href="../megaparsec-9.5.0/Text-Megaparsec-Stream.html#t:Stream" title="Text.Megaparsec.Stream">Stream</a> s, <a href="../base-4.18.2.0/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> s, <a href="../megaparsec-9.5.0/Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s <a href="../base-4.18.2.0/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> s)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="../megaparsec-9.5.0/Text-Megaparsec.html#t:Parsec" title="Text.Megaparsec">Parsec</a> e s a</td><td class="doc"><p>The pattern matching parser <code>sep</code></p></td></tr><tr><td class="src">-&gt; (a -&gt; s)</td><td class="doc"><p>The <code>editor</code> function. Takes a parsed result of <code>sep</code>
 and returns a new stream section for the replacement.</p></td></tr><tr><td class="src">-&gt; s</td><td class="doc"><p>The input stream of text to be edited</p></td></tr><tr><td class="src">-&gt; s</td><td class="doc"><p>The edited input stream</p></td></tr></table></div><div class="doc"><h3>Stream editor</h3><p>Also known as &#8220;find-and-replace&#8221;, or &#8220;match-and-substitute&#8221;. Finds all
 non-overlapping sections of the stream which match the pattern <code>sep</code>,
 and replaces them with the result of the <code>editor</code> function.</p><h4>Access the matched section of text in the <code>editor</code></h4><p>If you want access to the matched string in the <code>editor</code> function,
 then combine the pattern parser <code>sep</code> with <code><a href="../megaparsec-9.5.0/Text-Megaparsec.html#v:match" title="Text.Megaparsec">match</a></code>.
 This will effectively change the type of the <code>editor</code> function
 to <code>(s,a) -&gt; s</code>.</p><p>This allows us to write an <code>editor</code> function which can choose to not
 edit the match and just leave it as it is. If the <code>editor</code> function
 returns the first item in the tuple, then <code>streamEdit</code> will not change
 the matched string.</p><p>So, for all <code>sep</code>:</p><pre>streamEdit (<code><a href="../megaparsec-9.5.0/Text-Megaparsec.html#v:match" title="Text.Megaparsec">match</a></code> sep) <code><a href="../base-4.18.2.0/Data-Tuple.html#v:fst" title="Data.Tuple">fst</a></code> &#8801; <code><a href="../base-4.18.2.0/Data-Function.html#v:id" title="Data.Function">id</a></code>
</pre></div></div><div class="top"><p class="src"><a id="v:streamEditT" class="def">streamEditT</a> <a href="src/Replace.Megaparsec.html#streamEditT" class="link">Source</a> <a href="#v:streamEditT" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <span class="keyword">forall</span> e s m a. (<a href="../base-4.18.2.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> e, <a href="../megaparsec-9.5.0/Text-Megaparsec-Stream.html#t:Stream" title="Text.Megaparsec.Stream">Stream</a> s, <a href="../base-4.18.2.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="../base-4.18.2.0/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> s, <a href="../megaparsec-9.5.0/Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s <a href="../base-4.18.2.0/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> s)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="../megaparsec-9.5.0/Text-Megaparsec-Internal.html#t:ParsecT" title="Text.Megaparsec.Internal">ParsecT</a> e s m a</td><td class="doc"><p>The pattern matching parser <code>sep</code></p></td></tr><tr><td class="src">-&gt; (a -&gt; m s)</td><td class="doc"><p>The <code>editor</code> function. Takes a parsed result of <code>sep</code>
 and returns a new stream section for the replacement.</p></td></tr><tr><td class="src">-&gt; s</td><td class="doc"><p>The input stream of text to be edited</p></td></tr><tr><td class="src">-&gt; m s</td><td class="doc"><p>The edited input stream</p></td></tr></table></div><div class="doc"><h3>Stream editor</h3><p>Monad transformer version of <code><a href="Replace-Megaparsec.html#v:streamEdit" title="Replace.Megaparsec">streamEdit</a></code>.</p><p>Both the parser <code>sep</code> and the <code>editor</code> function will run in the underlying
 monad context.</p><p>If you want to do <code><a href="../base-4.18.2.0/System-IO.html#t:IO" title="System.IO">IO</a></code> operations in the <code>editor</code> function or the
 parser <code>sep</code>, then run this in <code><a href="../base-4.18.2.0/System-IO.html#t:IO" title="System.IO">IO</a></code>.</p><p>If you want the <code>editor</code> function or the parser <code>sep</code> to remember some state,
 then run this in a stateful monad.</p></div></div><a href="#g:2" id="g:2"><h1>Parser combinator</h1></a><div class="doc"><p>Functions in this section are <em>parser combinators</em>. They take
 a <code>sep</code> parser for an argument, combine <code>sep</code> with another parser,
 and return a new parser.</p></div><div class="top"><p class="src"><a id="v:anyTill" class="def">anyTill</a> <a href="src/Replace.Megaparsec.html#anyTill" class="link">Source</a> <a href="#v:anyTill" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <span class="keyword">forall</span> e s m a. <a href="../megaparsec-9.5.0/Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; m a</td><td class="doc"><p>The pattern matching parser <code>sep</code></p></td></tr><tr><td class="src">-&gt; m (<a href="../megaparsec-9.5.0/Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s, a)</td><td class="doc"><p>parser</p></td></tr></table></div><div class="doc"><h3>Specialized <a href="http://hackage.haskell.org/package/parser-combinators/docs/Control-Monad-Combinators.html#v:manyTill_">manyTill_</a></h3><p>Parser combinator to consume input until the <code>sep</code> pattern matches,
 equivalent to
 <code><code><a href="../parser-combinators-1.3.0/Control-Monad-Combinators.html#v:manyTill_" title="Control.Monad.Combinators">manyTill_</a></code> <code><a href="../megaparsec-9.5.0/Text-Megaparsec.html#v:anySingle" title="Text.Megaparsec">anySingle</a></code> sep</code>.
 On success, returns the prefix before the pattern match and the parsed match.</p><p><code>sep</code> may be a zero-width parser, it may succeed without consuming any
 input.</p><p>This combinator will produce a parser which
 acts like <code><a href="../megaparsec-9.5.0/Text-Megaparsec.html#v:takeWhileP" title="Text.Megaparsec">takeWhileP</a></code> but is predicated beyond more than
 just the next one token. <code><a href="Replace-Megaparsec.html#v:anyTill" title="Replace.Megaparsec">anyTill</a></code> is also like <code><a href="../megaparsec-9.5.0/Text-Megaparsec.html#v:takeWhileP" title="Text.Megaparsec">takeWhileP</a></code>
 in that it will be &#8220;fast&#8221; when applied to an input stream type <code>s</code>
 for which there are specialization re-write rules.</p></div></div><div class="top"><p class="src"><a id="v:sepCap" class="def">sepCap</a> <a href="src/Replace.Megaparsec.html#sepCap" class="link">Source</a> <a href="#v:sepCap" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <span class="keyword">forall</span> e s m a. <a href="../megaparsec-9.5.0/Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; m a</td><td class="doc"><p>The pattern matching parser <code>sep</code></p></td></tr><tr><td class="src">-&gt; m [<a href="../base-4.18.2.0/Data-Either.html#t:Either" title="Data.Either">Either</a> (<a href="../megaparsec-9.5.0/Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s) a]</td><td class="doc"><p>parser</p></td></tr></table></div><div class="doc"><h3>Separate and capture</h3><p>Parser combinator to find all of the leftmost non-overlapping occurrences
 of the pattern parser <code>sep</code> in a text stream.
 The <code><a href="Replace-Megaparsec.html#v:sepCap" title="Replace.Megaparsec">sepCap</a></code> parser will always consume its entire input and can never fail.</p><p><code>sepCap</code> is similar to the <code>sep*</code> family of parser combinators
 found in
 <a href="http://hackage.haskell.org/package/parser-combinators/docs/Control-Monad-Combinators.html">parser-combinators</a>
 and
 <a href="http://hackage.haskell.org/package/parsers/docs/Text-Parser-Combinators.html">parsers</a>,
 but it returns the parsed result of the <code>sep</code> parser instead
 of throwing it away.</p><h4>Output</h4><p>The input stream is separated and output into a list of sections:</p><ul><li>Sections which can parsed by the pattern <code>sep</code> will be parsed and captured
   as <code><a href="../base-4.18.2.0/Data-Either.html#v:Right" title="Data.Either">Right</a></code>.</li><li>Non-matching sections of the stream will be captured in <code><a href="../base-4.18.2.0/Data-Either.html#v:Left" title="Data.Either">Left</a></code>.</li></ul><p>The output list also has these properties:</p><ul><li>If the input is <code>&quot;&quot;</code> then the output list will be <code>[]</code>.</li><li>If there are no pattern matches, then
   the entire input stream will be returned as one non-matching <code><a href="../base-4.18.2.0/Data-Either.html#v:Left" title="Data.Either">Left</a></code> section.</li><li>The output list will not contain two consecutive <code><a href="../base-4.18.2.0/Data-Either.html#v:Left" title="Data.Either">Left</a></code> sections.</li></ul><h4>Zero-width matches forbidden</h4><p>If the pattern matching parser <code>sep</code> would succeed without consuming any
 input then <code><a href="Replace-Megaparsec.html#v:sepCap" title="Replace.Megaparsec">sepCap</a></code> will force it to fail.
 If we allow <code>sep</code> to match a zero-width pattern,
 then it can match the same zero-width pattern again at the same position
 on the next iteration, which would result in an infinite number of
 overlapping pattern matches.</p></div></div><div class="top"><p class="src"><a id="v:findAll" class="def">findAll</a> <a href="src/Replace.Megaparsec.html#findAll" class="link">Source</a> <a href="#v:findAll" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../megaparsec-9.5.0/Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; m a</td><td class="doc"><p>The pattern matching parser <code>sep</code></p></td></tr><tr><td class="src">-&gt; m [<a href="../base-4.18.2.0/Data-Either.html#t:Either" title="Data.Either">Either</a> (<a href="../megaparsec-9.5.0/Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s) (<a href="../megaparsec-9.5.0/Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s)]</td><td class="doc"><p>parser</p></td></tr></table></div><div class="doc"><div class="warning"><p>Deprecated: replace with `findAll sep = (fmap.fmap) (second fst) $ sepCap (match sep)`</p></div><h3>Find all occurences</h3><p>Parser combinator for finding all occurences of a pattern in a stream.</p><p>Will call <code><a href="Replace-Megaparsec.html#v:sepCap" title="Replace.Megaparsec">sepCap</a></code> with the <code><a href="../megaparsec-9.5.0/Text-Megaparsec.html#v:match" title="Text.Megaparsec">match</a></code> combinator and
 return the text which matched the pattern parser <code>sep</code> in
 the <code><a href="../base-4.18.2.0/Data-Either.html#v:Right" title="Data.Either">Right</a></code> sections.</p><p>Definition:</p><pre>findAll sep = (fmap.fmap) (<code><a href="../base-4.18.2.0/Data-Bifunctor.html#v:second" title="Data.Bifunctor">second</a></code> fst) $ <code><a href="Replace-Megaparsec.html#v:sepCap" title="Replace.Megaparsec">sepCap</a></code> (<code><a href="../megaparsec-9.5.0/Text-Megaparsec.html#v:match" title="Text.Megaparsec">match</a></code> sep)
</pre></div></div><div class="top"><p class="src"><a id="v:findAllCap" class="def">findAllCap</a> <a href="src/Replace.Megaparsec.html#findAllCap" class="link">Source</a> <a href="#v:findAllCap" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../megaparsec-9.5.0/Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; m a</td><td class="doc"><p>The pattern matching parser <code>sep</code></p></td></tr><tr><td class="src">-&gt; m [<a href="../base-4.18.2.0/Data-Either.html#t:Either" title="Data.Either">Either</a> (<a href="../megaparsec-9.5.0/Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s) (<a href="../megaparsec-9.5.0/Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s, a)]</td><td class="doc"><p>parser</p></td></tr></table></div><div class="doc"><div class="warning"><p>Deprecated: replace with `findAllCap sep = sepCap (match sep)`</p></div><h3>Find all occurences, parse and capture pattern matches</h3><p>Parser combinator for finding all occurences of a pattern in a stream.</p><p>Will call <code><a href="Replace-Megaparsec.html#v:sepCap" title="Replace.Megaparsec">sepCap</a></code> with the <code><a href="../megaparsec-9.5.0/Text-Megaparsec.html#v:match" title="Text.Megaparsec">match</a></code> combinator so that
 the text which matched the pattern parser <code>sep</code> will be returned in
 the <code><a href="../base-4.18.2.0/Data-Either.html#v:Right" title="Data.Either">Right</a></code> sections, along with the result of the parse of <code>sep</code>.</p><p>Definition:</p><pre>findAllCap sep = <code><a href="Replace-Megaparsec.html#v:sepCap" title="Replace.Megaparsec">sepCap</a></code> (<code><a href="../megaparsec-9.5.0/Text-Megaparsec.html#v:match" title="Text.Megaparsec">match</a></code> sep)
</pre></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.29.2</p></div></body></html>