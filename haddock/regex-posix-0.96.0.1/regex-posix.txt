-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | POSIX Backend for "Text.Regex" (regex-base)
--   
--   The POSIX regex backend for <a>regex-base</a>.
--   
--   The main appeal of this backend is that it's very lightweight due to
--   its reliance on the ubiquitous <a>POSIX.2 regex</a> facility that is
--   provided by the standard C library on most POSIX platforms.
--   
--   See also <a>https://wiki.haskell.org/Regular_expressions</a> for more
--   information.
@package regex-posix
@version 0.96.0.1


-- | WrapPosix.hsc exports a wrapped version of the ffi imports. To
--   increase type safety, the flags are newtype'd. The other important
--   export is a <a>Regex</a> type that is specific to the Posix library
--   backend. The flags are documented in <a>Text.Regex.Posix</a>. The
--   <a>defaultCompOpt</a> is <tt>(compExtended .|. compNewline)</tt>.
--   
--   The <a>Regex</a>, <a>CompOption</a>, and <a>ExecOption</a> types and
--   their <a>RegexOptions</a> instance is declared. The <a>=~</a> and
--   <a>=~~</a> convenience functions are defined.
--   
--   This module will fail or error only if allocation fails or a nullPtr
--   is passed in.
--   
--   2009-January : <a>wrapMatchAll</a> and <a>wrapCount</a> now adjust the
--   execution option <a>execNotBOL</a> after the first result to take into
--   account 'n' in the text immediately before the next matches. (version
--   0.93.3)
--   
--   2009-January : <a>wrapMatchAll</a> and <a>wrapCount</a> have been
--   changed to return all non-overlapping matches, including empty matches
--   even if they coincide with the end of the previous non-empty match.
--   The change is that the first non-empty match no longer terminates the
--   search. One can filter the results to obtain the old behavior or to
--   obtain the behavior of "sed", where "sed" eliminates the empty matches
--   which coincide with the end of non-empty matches. (version 0.94.0)
module Text.Regex.Posix.Wrap

-- | A compiled regular expression.
data Regex

-- | <a>RegOffset</a> is <tt>typedef int regoff_t</tt> on Linux and
--   ultimately <tt>typedef long long __int64_t</tt> on Max OS X. So rather
--   than saying 2,147,483,647 is all the length you need, I'll take the
--   larger: 9,223,372,036,854,775,807 should be enough bytes for anyone,
--   no need for Integer. The alternative is to compile to different sizes
--   in a platform dependent manner with <tt>type RegOffset = (#type
--   regoff_t)</tt>, which I do not want to do.
--   
--   There is also a special value <tt><a>unusedRegOffset</a> ::
--   <a>RegOffset</a></tt> which is (-1) and as a starting index means that
--   the subgroup capture was unused. Otherwise the <a>RegOffset</a>
--   indicates a character boundary that is before the character at that
--   index offset, with the first character at index offset 0. So starting
--   at 1 and ending at 2 means to take only the second character.
type RegOffset = Int64
type RegOffsetT = (Int32)
(=~) :: (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
(=~~) :: (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target, MonadFail m) => source1 -> source -> m target

-- | The return code will be <tt>retOk</tt> when it is the Haskell wrapper
--   and not the underlying library generating the error message.
type WrapError = (ReturnCode, String)
wrapCompile :: CompOption -> ExecOption -> CString -> IO (Either WrapError Regex)
wrapTest :: Regex -> CString -> IO (Either WrapError Bool)

-- | <a>wrapMatch</a> returns offsets for the begin and end of each
--   capture. Unused captures have offsets of <a>unusedRegOffset</a> which
--   is (-1).
wrapMatch :: Regex -> CString -> IO (Either WrapError (Maybe [(RegOffset, RegOffset)]))

-- | <a>wrapMatchAll</a> returns the offset and length of each capture.
--   Unused captures have an offset of <a>unusedRegOffset</a> which is (-1)
--   and length of 0.
wrapMatchAll :: Regex -> CString -> IO (Either WrapError [MatchArray])
wrapCount :: Regex -> CString -> IO (Either WrapError Int)
unusedRegOffset :: RegOffset

-- | A bitmapped <a>CInt</a> containing options for compilation of regular
--   expressions. Option values (and their man 3 regcomp names) are
--   
--   <ul>
--   <li><a>compBlank</a> which is a completely zero value for all the
--   flags. This is also the <a>blankCompOpt</a> value.</li>
--   <li><a>compExtended</a> (REG_EXTENDED) which can be set to use
--   extended instead of basic regular expressions. This is set in the
--   <a>defaultCompOpt</a> value.</li>
--   <li><a>compNewline</a> (REG_NEWLINE) turns on newline sensitivity: The
--   dot (.) and inverted set <tt>[^ ]</tt> never match newline, and ^ and
--   $ anchors do match after and before newlines. This is set in the
--   <a>defaultCompOpt</a> value.</li>
--   <li><a>compIgnoreCase</a> (REG_ICASE) which can be set to match
--   ignoring upper and lower distinctions.</li>
--   <li><a>compNoSub</a> (REG_NOSUB) which turns off all information from
--   matching except whether a match exists.</li>
--   </ul>
newtype CompOption
CompOption :: CInt -> CompOption

-- | A completely zero value for all the flags. This is also the
--   <a>blankCompOpt</a> value.
compBlank :: CompOption
compExtended :: CompOption
compIgnoreCase :: CompOption
compNoSub :: CompOption
compNewline :: CompOption

-- | A bitmapped <a>CInt</a> containing options for execution of compiled
--   regular expressions. Option values (and their man 3 regexec names) are
--   
--   <ul>
--   <li><a>execBlank</a> which is a complete zero value for all the flags.
--   This is the <tt>blankExecOpt</tt> value.</li>
--   <li><a>execNotBOL</a> (REG_NOTBOL) can be set to prevent ^ from
--   matching at the start of the input.</li>
--   <li><a>execNotEOL</a> (REG_NOTEOL) can be set to prevent $ from
--   matching at the end of the input (before the terminating NUL).</li>
--   </ul>
newtype ExecOption
ExecOption :: CInt -> ExecOption

-- | A completely zero value for all the flags. This is also the
--   <a>blankExecOpt</a> value.
execBlank :: ExecOption
execNotBOL :: ExecOption
execNotEOL :: ExecOption

-- | ReturnCode is an enumerated <a>CInt</a>, corresponding to the error
--   codes from <tt>man 3 regex</tt>:
--   
--   <ul>
--   <li><a>retBadbr</a> (<tt>REG_BADBR</tt>) invalid repetition count(s)
--   in <tt>{ }</tt></li>
--   <li><a>retBadpat</a> (<tt>REG_BADPAT</tt>) invalid regular
--   expression</li>
--   <li><a>retBadrpt</a> (<tt>REG_BADRPT</tt>) <tt>?</tt>, <tt>*</tt>, or
--   <tt>+</tt> operand invalid</li>
--   <li><a>retEcollate</a> (<tt>REG_ECOLLATE</tt>) invalid collating
--   element</li>
--   <li><a>retEctype</a> (<tt>REG_ECTYPE</tt>) invalid character
--   class</li>
--   <li><a>retEescape</a> (<tt>REG_EESCAPE</tt>) <tt>\</tt> applied to
--   unescapable character</li>
--   <li><a>retEsubreg</a> (<tt>REG_ESUBREG</tt>) invalid backreference
--   number</li>
--   <li><a>retEbrack</a> (<tt>REG_EBRACK</tt>) brackets <tt>[ ]</tt> not
--   balanced</li>
--   <li><a>retEparen</a> (<tt>REG_EPAREN</tt>) parentheses <tt>( )</tt>
--   not balanced</li>
--   <li><a>retEbrace</a> (<tt>REG_EBRACE</tt>) braces <tt>{ }</tt> not
--   balanced</li>
--   <li><a>retErange</a> (<tt>REG_ERANGE</tt>) invalid character range in
--   <tt>[ ]</tt></li>
--   <li><a>retEspace</a> (<tt>REG_ESPACE</tt>) ran out of memory</li>
--   <li><a>retNoMatch</a> (<tt>REG_NOMATCH</tt>) The regexec() function
--   failed to match</li>
--   </ul>
newtype ReturnCode
ReturnCode :: CInt -> ReturnCode
retBadbr :: ReturnCode
retBadpat :: ReturnCode
retBadrpt :: ReturnCode
retEcollate :: ReturnCode
retEctype :: ReturnCode
retEescape :: ReturnCode
retEsubreg :: ReturnCode
retEbrack :: ReturnCode
retEparen :: ReturnCode
retEbrace :: ReturnCode
retErange :: ReturnCode
retEspace :: ReturnCode
instance GHC.Bits.Bits Text.Regex.Posix.Wrap.CompOption
instance GHC.Num.Num Text.Regex.Posix.Wrap.CompOption
instance GHC.Show.Show Text.Regex.Posix.Wrap.CompOption
instance GHC.Classes.Eq Text.Regex.Posix.Wrap.CompOption
instance GHC.Bits.Bits Text.Regex.Posix.Wrap.ExecOption
instance GHC.Num.Num Text.Regex.Posix.Wrap.ExecOption
instance GHC.Show.Show Text.Regex.Posix.Wrap.ExecOption
instance GHC.Classes.Eq Text.Regex.Posix.Wrap.ExecOption
instance GHC.Show.Show Text.Regex.Posix.Wrap.ReturnCode
instance GHC.Classes.Eq Text.Regex.Posix.Wrap.ReturnCode
instance Text.Regex.Base.RegexLike.RegexOptions Text.Regex.Posix.Wrap.Regex Text.Regex.Posix.Wrap.CompOption Text.Regex.Posix.Wrap.ExecOption


-- | This provides <a>String</a> instances for <a>RegexMaker</a> and
--   <a>RegexLike</a> based on <a>Text.Regex.Posix.Wrap</a>, and a
--   (<a>RegexContext</a> <a>Regex</a> <a>String</a> <a>String</a>)
--   instance.
--   
--   To use these instance, you would normally import
--   <a>Text.Regex.Posix</a>. You only need to import this module to use
--   the medium level API of the compile, regexec, and execute functions.
--   All of these report error by returning Left values instead of
--   undefined or error or fail.
module Text.Regex.Posix.String

-- | A compiled regular expression.
data Regex

-- | 0 based index from start of source, or (-1) for unused
type MatchOffset = Int

-- | non-negative length of a match
type MatchLength = Int

-- | ReturnCode is an enumerated <a>CInt</a>, corresponding to the error
--   codes from <tt>man 3 regex</tt>:
--   
--   <ul>
--   <li><a>retBadbr</a> (<tt>REG_BADBR</tt>) invalid repetition count(s)
--   in <tt>{ }</tt></li>
--   <li><a>retBadpat</a> (<tt>REG_BADPAT</tt>) invalid regular
--   expression</li>
--   <li><a>retBadrpt</a> (<tt>REG_BADRPT</tt>) <tt>?</tt>, <tt>*</tt>, or
--   <tt>+</tt> operand invalid</li>
--   <li><a>retEcollate</a> (<tt>REG_ECOLLATE</tt>) invalid collating
--   element</li>
--   <li><a>retEctype</a> (<tt>REG_ECTYPE</tt>) invalid character
--   class</li>
--   <li><a>retEescape</a> (<tt>REG_EESCAPE</tt>) <tt>\</tt> applied to
--   unescapable character</li>
--   <li><a>retEsubreg</a> (<tt>REG_ESUBREG</tt>) invalid backreference
--   number</li>
--   <li><a>retEbrack</a> (<tt>REG_EBRACK</tt>) brackets <tt>[ ]</tt> not
--   balanced</li>
--   <li><a>retEparen</a> (<tt>REG_EPAREN</tt>) parentheses <tt>( )</tt>
--   not balanced</li>
--   <li><a>retEbrace</a> (<tt>REG_EBRACE</tt>) braces <tt>{ }</tt> not
--   balanced</li>
--   <li><a>retErange</a> (<tt>REG_ERANGE</tt>) invalid character range in
--   <tt>[ ]</tt></li>
--   <li><a>retEspace</a> (<tt>REG_ESPACE</tt>) ran out of memory</li>
--   <li><a>retNoMatch</a> (<tt>REG_NOMATCH</tt>) The regexec() function
--   failed to match</li>
--   </ul>
data ReturnCode

-- | The return code will be <tt>retOk</tt> when it is the Haskell wrapper
--   and not the underlying library generating the error message.
type WrapError = (ReturnCode, String)
unusedOffset :: Int
compile :: CompOption -> ExecOption -> String -> IO (Either WrapError Regex)

-- | Matches a regular expression against a string
regexec :: Regex -> String -> IO (Either WrapError (Maybe (String, String, String, [String])))

-- | Matches a regular expression against a string
execute :: Regex -> String -> IO (Either WrapError (Maybe (Array Int (MatchOffset, MatchLength))))

-- | A bitmapped <a>CInt</a> containing options for compilation of regular
--   expressions. Option values (and their man 3 regcomp names) are
--   
--   <ul>
--   <li><a>compBlank</a> which is a completely zero value for all the
--   flags. This is also the <a>blankCompOpt</a> value.</li>
--   <li><a>compExtended</a> (REG_EXTENDED) which can be set to use
--   extended instead of basic regular expressions. This is set in the
--   <a>defaultCompOpt</a> value.</li>
--   <li><a>compNewline</a> (REG_NEWLINE) turns on newline sensitivity: The
--   dot (.) and inverted set <tt>[^ ]</tt> never match newline, and ^ and
--   $ anchors do match after and before newlines. This is set in the
--   <a>defaultCompOpt</a> value.</li>
--   <li><a>compIgnoreCase</a> (REG_ICASE) which can be set to match
--   ignoring upper and lower distinctions.</li>
--   <li><a>compNoSub</a> (REG_NOSUB) which turns off all information from
--   matching except whether a match exists.</li>
--   </ul>
newtype CompOption
CompOption :: CInt -> CompOption

-- | A completely zero value for all the flags. This is also the
--   <a>blankCompOpt</a> value.
compBlank :: CompOption
compExtended :: CompOption
compIgnoreCase :: CompOption
compNoSub :: CompOption
compNewline :: CompOption

-- | A bitmapped <a>CInt</a> containing options for execution of compiled
--   regular expressions. Option values (and their man 3 regexec names) are
--   
--   <ul>
--   <li><a>execBlank</a> which is a complete zero value for all the flags.
--   This is the <tt>blankExecOpt</tt> value.</li>
--   <li><a>execNotBOL</a> (REG_NOTBOL) can be set to prevent ^ from
--   matching at the start of the input.</li>
--   <li><a>execNotEOL</a> (REG_NOTEOL) can be set to prevent $ from
--   matching at the end of the input (before the terminating NUL).</li>
--   </ul>
newtype ExecOption
ExecOption :: CInt -> ExecOption

-- | A completely zero value for all the flags. This is also the
--   <a>blankExecOpt</a> value.
execBlank :: ExecOption
execNotBOL :: ExecOption
execNotEOL :: ExecOption
instance Text.Regex.Base.RegexLike.RegexContext Text.Regex.Posix.Wrap.Regex GHC.Base.String GHC.Base.String
instance Text.Regex.Base.RegexLike.RegexMaker Text.Regex.Posix.Wrap.Regex Text.Regex.Posix.Wrap.CompOption Text.Regex.Posix.Wrap.ExecOption GHC.Base.String
instance Text.Regex.Base.RegexLike.RegexLike Text.Regex.Posix.Wrap.Regex GHC.Base.String


-- | This provides <a>String</a> instances for <a>RegexMaker</a> and
--   <a>RegexLike</a> based on <a>Text.Regex.Posix.Wrap</a>, and a
--   (<a>RegexContext</a> <a>Regex</a> <a>String</a> <a>String</a>)
--   instance.
--   
--   To use these instance, you would normally import
--   <a>Text.Regex.Posix</a>. You only need to import this module to use
--   the medium level API of the compile, regexec, and execute functions.
--   All of these report error by returning Left values instead of
--   undefined or error or fail.
module Text.Regex.Posix.Sequence

-- | A compiled regular expression.
data Regex

-- | 0 based index from start of source, or (-1) for unused
type MatchOffset = Int

-- | non-negative length of a match
type MatchLength = Int

-- | ReturnCode is an enumerated <a>CInt</a>, corresponding to the error
--   codes from <tt>man 3 regex</tt>:
--   
--   <ul>
--   <li><a>retBadbr</a> (<tt>REG_BADBR</tt>) invalid repetition count(s)
--   in <tt>{ }</tt></li>
--   <li><a>retBadpat</a> (<tt>REG_BADPAT</tt>) invalid regular
--   expression</li>
--   <li><a>retBadrpt</a> (<tt>REG_BADRPT</tt>) <tt>?</tt>, <tt>*</tt>, or
--   <tt>+</tt> operand invalid</li>
--   <li><a>retEcollate</a> (<tt>REG_ECOLLATE</tt>) invalid collating
--   element</li>
--   <li><a>retEctype</a> (<tt>REG_ECTYPE</tt>) invalid character
--   class</li>
--   <li><a>retEescape</a> (<tt>REG_EESCAPE</tt>) <tt>\</tt> applied to
--   unescapable character</li>
--   <li><a>retEsubreg</a> (<tt>REG_ESUBREG</tt>) invalid backreference
--   number</li>
--   <li><a>retEbrack</a> (<tt>REG_EBRACK</tt>) brackets <tt>[ ]</tt> not
--   balanced</li>
--   <li><a>retEparen</a> (<tt>REG_EPAREN</tt>) parentheses <tt>( )</tt>
--   not balanced</li>
--   <li><a>retEbrace</a> (<tt>REG_EBRACE</tt>) braces <tt>{ }</tt> not
--   balanced</li>
--   <li><a>retErange</a> (<tt>REG_ERANGE</tt>) invalid character range in
--   <tt>[ ]</tt></li>
--   <li><a>retEspace</a> (<tt>REG_ESPACE</tt>) ran out of memory</li>
--   <li><a>retNoMatch</a> (<tt>REG_NOMATCH</tt>) The regexec() function
--   failed to match</li>
--   </ul>
data ReturnCode

-- | The return code will be <tt>retOk</tt> when it is the Haskell wrapper
--   and not the underlying library generating the error message.
type WrapError = (ReturnCode, String)
unusedOffset :: Int
compile :: CompOption -> ExecOption -> Seq Char -> IO (Either WrapError Regex)

-- | Matches a regular expression against a string
regexec :: Regex -> Seq Char -> IO (Either WrapError (Maybe (Seq Char, Seq Char, Seq Char, [Seq Char])))

-- | Matches a regular expression against a string
execute :: Regex -> Seq Char -> IO (Either WrapError (Maybe (Array Int (MatchOffset, MatchLength))))

-- | A bitmapped <a>CInt</a> containing options for compilation of regular
--   expressions. Option values (and their man 3 regcomp names) are
--   
--   <ul>
--   <li><a>compBlank</a> which is a completely zero value for all the
--   flags. This is also the <a>blankCompOpt</a> value.</li>
--   <li><a>compExtended</a> (REG_EXTENDED) which can be set to use
--   extended instead of basic regular expressions. This is set in the
--   <a>defaultCompOpt</a> value.</li>
--   <li><a>compNewline</a> (REG_NEWLINE) turns on newline sensitivity: The
--   dot (.) and inverted set <tt>[^ ]</tt> never match newline, and ^ and
--   $ anchors do match after and before newlines. This is set in the
--   <a>defaultCompOpt</a> value.</li>
--   <li><a>compIgnoreCase</a> (REG_ICASE) which can be set to match
--   ignoring upper and lower distinctions.</li>
--   <li><a>compNoSub</a> (REG_NOSUB) which turns off all information from
--   matching except whether a match exists.</li>
--   </ul>
newtype CompOption
CompOption :: CInt -> CompOption

-- | A completely zero value for all the flags. This is also the
--   <a>blankCompOpt</a> value.
compBlank :: CompOption
compExtended :: CompOption
compIgnoreCase :: CompOption
compNoSub :: CompOption
compNewline :: CompOption

-- | A bitmapped <a>CInt</a> containing options for execution of compiled
--   regular expressions. Option values (and their man 3 regexec names) are
--   
--   <ul>
--   <li><a>execBlank</a> which is a complete zero value for all the flags.
--   This is the <tt>blankExecOpt</tt> value.</li>
--   <li><a>execNotBOL</a> (REG_NOTBOL) can be set to prevent ^ from
--   matching at the start of the input.</li>
--   <li><a>execNotEOL</a> (REG_NOTEOL) can be set to prevent $ from
--   matching at the end of the input (before the terminating NUL).</li>
--   </ul>
newtype ExecOption
ExecOption :: CInt -> ExecOption

-- | A completely zero value for all the flags. This is also the
--   <a>blankExecOpt</a> value.
execBlank :: ExecOption
execNotBOL :: ExecOption
execNotEOL :: ExecOption
instance Text.Regex.Base.RegexLike.RegexContext Text.Regex.Posix.Wrap.Regex (Data.Sequence.Internal.Seq GHC.Types.Char) (Data.Sequence.Internal.Seq GHC.Types.Char)
instance Text.Regex.Base.RegexLike.RegexMaker Text.Regex.Posix.Wrap.Regex Text.Regex.Posix.Wrap.CompOption Text.Regex.Posix.Wrap.ExecOption (Data.Sequence.Internal.Seq GHC.Types.Char)
instance Text.Regex.Base.RegexLike.RegexLike Text.Regex.Posix.Wrap.Regex (Data.Sequence.Internal.Seq GHC.Types.Char)


-- | This provides <a>ByteString</a> instances for RegexMaker and RegexLike
--   based on <a>Text.Regex.Posix.Wrap</a>, and a (RegexContext Regex
--   ByteString ByteString) instance.
--   
--   To use these instance, you would normally import
--   <a>Text.Regex.Posix</a>. You only need to import this module to use
--   the medium level API of the compile, regexec, and execute functions.
--   All of these report error by returning Left values instead of
--   undefined or error or fail.
--   
--   The ByteString will only be passed to the library efficiently (as a
--   pointer) if it ends in a NUL byte. Otherwise a temporary copy must be
--   made with the 0 byte appended.
module Text.Regex.Posix.ByteString

-- | A compiled regular expression.
data Regex

-- | 0 based index from start of source, or (-1) for unused
type MatchOffset = Int

-- | non-negative length of a match
type MatchLength = Int

-- | ReturnCode is an enumerated <a>CInt</a>, corresponding to the error
--   codes from <tt>man 3 regex</tt>:
--   
--   <ul>
--   <li><a>retBadbr</a> (<tt>REG_BADBR</tt>) invalid repetition count(s)
--   in <tt>{ }</tt></li>
--   <li><a>retBadpat</a> (<tt>REG_BADPAT</tt>) invalid regular
--   expression</li>
--   <li><a>retBadrpt</a> (<tt>REG_BADRPT</tt>) <tt>?</tt>, <tt>*</tt>, or
--   <tt>+</tt> operand invalid</li>
--   <li><a>retEcollate</a> (<tt>REG_ECOLLATE</tt>) invalid collating
--   element</li>
--   <li><a>retEctype</a> (<tt>REG_ECTYPE</tt>) invalid character
--   class</li>
--   <li><a>retEescape</a> (<tt>REG_EESCAPE</tt>) <tt>\</tt> applied to
--   unescapable character</li>
--   <li><a>retEsubreg</a> (<tt>REG_ESUBREG</tt>) invalid backreference
--   number</li>
--   <li><a>retEbrack</a> (<tt>REG_EBRACK</tt>) brackets <tt>[ ]</tt> not
--   balanced</li>
--   <li><a>retEparen</a> (<tt>REG_EPAREN</tt>) parentheses <tt>( )</tt>
--   not balanced</li>
--   <li><a>retEbrace</a> (<tt>REG_EBRACE</tt>) braces <tt>{ }</tt> not
--   balanced</li>
--   <li><a>retErange</a> (<tt>REG_ERANGE</tt>) invalid character range in
--   <tt>[ ]</tt></li>
--   <li><a>retEspace</a> (<tt>REG_ESPACE</tt>) ran out of memory</li>
--   <li><a>retNoMatch</a> (<tt>REG_NOMATCH</tt>) The regexec() function
--   failed to match</li>
--   </ul>
data ReturnCode

-- | The return code will be <tt>retOk</tt> when it is the Haskell wrapper
--   and not the underlying library generating the error message.
type WrapError = (ReturnCode, String)
unusedOffset :: Int

-- | Compiles a regular expression
compile :: CompOption -> ExecOption -> ByteString -> IO (Either WrapError Regex)

-- | Matches a regular expression against a buffer, returning the buffer
--   indicies of the match, and any submatches
--   
--   | Matches a regular expression against a string
execute :: Regex -> ByteString -> IO (Either WrapError (Maybe (Array Int (MatchOffset, MatchLength))))
regexec :: Regex -> ByteString -> IO (Either WrapError (Maybe (ByteString, ByteString, ByteString, [ByteString])))

-- | A bitmapped <a>CInt</a> containing options for compilation of regular
--   expressions. Option values (and their man 3 regcomp names) are
--   
--   <ul>
--   <li><a>compBlank</a> which is a completely zero value for all the
--   flags. This is also the <a>blankCompOpt</a> value.</li>
--   <li><a>compExtended</a> (REG_EXTENDED) which can be set to use
--   extended instead of basic regular expressions. This is set in the
--   <a>defaultCompOpt</a> value.</li>
--   <li><a>compNewline</a> (REG_NEWLINE) turns on newline sensitivity: The
--   dot (.) and inverted set <tt>[^ ]</tt> never match newline, and ^ and
--   $ anchors do match after and before newlines. This is set in the
--   <a>defaultCompOpt</a> value.</li>
--   <li><a>compIgnoreCase</a> (REG_ICASE) which can be set to match
--   ignoring upper and lower distinctions.</li>
--   <li><a>compNoSub</a> (REG_NOSUB) which turns off all information from
--   matching except whether a match exists.</li>
--   </ul>
newtype CompOption
CompOption :: CInt -> CompOption

-- | A completely zero value for all the flags. This is also the
--   <a>blankCompOpt</a> value.
compBlank :: CompOption
compExtended :: CompOption
compIgnoreCase :: CompOption
compNoSub :: CompOption
compNewline :: CompOption

-- | A bitmapped <a>CInt</a> containing options for execution of compiled
--   regular expressions. Option values (and their man 3 regexec names) are
--   
--   <ul>
--   <li><a>execBlank</a> which is a complete zero value for all the flags.
--   This is the <tt>blankExecOpt</tt> value.</li>
--   <li><a>execNotBOL</a> (REG_NOTBOL) can be set to prevent ^ from
--   matching at the start of the input.</li>
--   <li><a>execNotEOL</a> (REG_NOTEOL) can be set to prevent $ from
--   matching at the end of the input (before the terminating NUL).</li>
--   </ul>
newtype ExecOption
ExecOption :: CInt -> ExecOption

-- | A completely zero value for all the flags. This is also the
--   <a>blankExecOpt</a> value.
execBlank :: ExecOption
execNotBOL :: ExecOption
execNotEOL :: ExecOption
instance Text.Regex.Base.RegexLike.RegexContext Text.Regex.Posix.Wrap.Regex Data.ByteString.Internal.Type.ByteString Data.ByteString.Internal.Type.ByteString
instance Text.Regex.Base.RegexLike.RegexMaker Text.Regex.Posix.Wrap.Regex Text.Regex.Posix.Wrap.CompOption Text.Regex.Posix.Wrap.ExecOption Data.ByteString.Internal.Type.ByteString
instance Text.Regex.Base.RegexLike.RegexLike Text.Regex.Posix.Wrap.Regex Data.ByteString.Internal.Type.ByteString


-- | This provides <a>Lazy</a> instances for RegexMaker and RegexLike based
--   on <a>Text.Regex.Posix.Wrap</a>, and a (RegexContext Regex ByteString
--   ByteString) instance.
--   
--   To use these instance, you would normally import
--   <a>Text.Regex.Posix</a>. You only need to import this module to use
--   the medium level API of the compile, regexec, and execute functions.
--   All of these report error by returning Left values instead of
--   undefined or error or fail.
--   
--   A Lazy ByteString with more than one chunk cannot be be passed to the
--   library efficiently (as a pointer). It will have to converted via a
--   full copy to a temporary normal bytestring (with a null byte appended
--   if necessary).
module Text.Regex.Posix.ByteString.Lazy

-- | A compiled regular expression.
data Regex

-- | 0 based index from start of source, or (-1) for unused
type MatchOffset = Int

-- | non-negative length of a match
type MatchLength = Int

-- | ReturnCode is an enumerated <a>CInt</a>, corresponding to the error
--   codes from <tt>man 3 regex</tt>:
--   
--   <ul>
--   <li><a>retBadbr</a> (<tt>REG_BADBR</tt>) invalid repetition count(s)
--   in <tt>{ }</tt></li>
--   <li><a>retBadpat</a> (<tt>REG_BADPAT</tt>) invalid regular
--   expression</li>
--   <li><a>retBadrpt</a> (<tt>REG_BADRPT</tt>) <tt>?</tt>, <tt>*</tt>, or
--   <tt>+</tt> operand invalid</li>
--   <li><a>retEcollate</a> (<tt>REG_ECOLLATE</tt>) invalid collating
--   element</li>
--   <li><a>retEctype</a> (<tt>REG_ECTYPE</tt>) invalid character
--   class</li>
--   <li><a>retEescape</a> (<tt>REG_EESCAPE</tt>) <tt>\</tt> applied to
--   unescapable character</li>
--   <li><a>retEsubreg</a> (<tt>REG_ESUBREG</tt>) invalid backreference
--   number</li>
--   <li><a>retEbrack</a> (<tt>REG_EBRACK</tt>) brackets <tt>[ ]</tt> not
--   balanced</li>
--   <li><a>retEparen</a> (<tt>REG_EPAREN</tt>) parentheses <tt>( )</tt>
--   not balanced</li>
--   <li><a>retEbrace</a> (<tt>REG_EBRACE</tt>) braces <tt>{ }</tt> not
--   balanced</li>
--   <li><a>retErange</a> (<tt>REG_ERANGE</tt>) invalid character range in
--   <tt>[ ]</tt></li>
--   <li><a>retEspace</a> (<tt>REG_ESPACE</tt>) ran out of memory</li>
--   <li><a>retNoMatch</a> (<tt>REG_NOMATCH</tt>) The regexec() function
--   failed to match</li>
--   </ul>
data ReturnCode

-- | The return code will be <tt>retOk</tt> when it is the Haskell wrapper
--   and not the underlying library generating the error message.
type WrapError = (ReturnCode, String)
unusedOffset :: Int

-- | Compiles a regular expression
compile :: CompOption -> ExecOption -> ByteString -> IO (Either WrapError Regex)

-- | Matches a regular expression against a buffer, returning the buffer
--   indicies of the match, and any submatches
--   
--   | Matches a regular expression against a string
execute :: Regex -> ByteString -> IO (Either WrapError (Maybe (Array Int (MatchOffset, MatchLength))))
regexec :: Regex -> ByteString -> IO (Either WrapError (Maybe (ByteString, ByteString, ByteString, [ByteString])))

-- | A bitmapped <a>CInt</a> containing options for compilation of regular
--   expressions. Option values (and their man 3 regcomp names) are
--   
--   <ul>
--   <li><a>compBlank</a> which is a completely zero value for all the
--   flags. This is also the <a>blankCompOpt</a> value.</li>
--   <li><a>compExtended</a> (REG_EXTENDED) which can be set to use
--   extended instead of basic regular expressions. This is set in the
--   <a>defaultCompOpt</a> value.</li>
--   <li><a>compNewline</a> (REG_NEWLINE) turns on newline sensitivity: The
--   dot (.) and inverted set <tt>[^ ]</tt> never match newline, and ^ and
--   $ anchors do match after and before newlines. This is set in the
--   <a>defaultCompOpt</a> value.</li>
--   <li><a>compIgnoreCase</a> (REG_ICASE) which can be set to match
--   ignoring upper and lower distinctions.</li>
--   <li><a>compNoSub</a> (REG_NOSUB) which turns off all information from
--   matching except whether a match exists.</li>
--   </ul>
newtype CompOption
CompOption :: CInt -> CompOption

-- | A completely zero value for all the flags. This is also the
--   <a>blankCompOpt</a> value.
compBlank :: CompOption
compExtended :: CompOption
compIgnoreCase :: CompOption
compNoSub :: CompOption
compNewline :: CompOption

-- | A bitmapped <a>CInt</a> containing options for execution of compiled
--   regular expressions. Option values (and their man 3 regexec names) are
--   
--   <ul>
--   <li><a>execBlank</a> which is a complete zero value for all the flags.
--   This is the <tt>blankExecOpt</tt> value.</li>
--   <li><a>execNotBOL</a> (REG_NOTBOL) can be set to prevent ^ from
--   matching at the start of the input.</li>
--   <li><a>execNotEOL</a> (REG_NOTEOL) can be set to prevent $ from
--   matching at the end of the input (before the terminating NUL).</li>
--   </ul>
newtype ExecOption
ExecOption :: CInt -> ExecOption

-- | A completely zero value for all the flags. This is also the
--   <a>blankExecOpt</a> value.
execBlank :: ExecOption
execNotBOL :: ExecOption
execNotEOL :: ExecOption
instance Text.Regex.Base.RegexLike.RegexContext Text.Regex.Posix.Wrap.Regex Data.ByteString.Lazy.Internal.ByteString Data.ByteString.Lazy.Internal.ByteString
instance Text.Regex.Base.RegexLike.RegexMaker Text.Regex.Posix.Wrap.Regex Text.Regex.Posix.Wrap.CompOption Text.Regex.Posix.Wrap.ExecOption Data.ByteString.Lazy.Internal.ByteString
instance Text.Regex.Base.RegexLike.RegexLike Text.Regex.Posix.Wrap.Regex Data.ByteString.Lazy.Internal.ByteString


-- | Module that provides the Regex backend that wraps the <a>C POSIX.2
--   regex api</a>. This is the backend being used by the
--   <a>regex-compat</a> package to replace <a>Text.Regex</a>.
--   
--   The <a>Text.Regex.Posix</a> module provides a backend for regular
--   expressions. If you import this along with other backends, then you
--   should do so with qualified imports, perhaps renamed for convenience.
--   
--   If the <a>=~</a> and <a>=~~</a> functions are too high level, you can
--   use the compile, regexec, and execute functions from importing either
--   <a>Text.Regex.Posix.String</a> or <a>Text.Regex.Posix.ByteString</a>.
--   If you want to use a low-level <a>CString</a> interface to the
--   library, then import <a>Text.Regex.Posix.Wrap</a> and use the wrap*
--   functions.
--   
--   This module is only efficient with <a>ByteString</a> only if it is
--   null terminated, i.e. <tt>(Bytestring.last bs)==0</tt>. Otherwise the
--   library must make a temporary copy of the <a>ByteString</a> and append
--   the <tt>NUL</tt> byte.
--   
--   A <a>String</a> will be converted into a <a>CString</a> for
--   processing. Doing this repeatedly will be very inefficient.
--   
--   Note that the posix library works with single byte characters, and
--   does not understand Unicode. If you need Unicode support you will have
--   to use a different backend.
--   
--   When offsets are reported for subexpression captures, a subexpression
--   that did not match anything (as opposed to matching an empty string)
--   will have its offset set to the <a>unusedRegOffset</a> value, which is
--   <tt>(-1)</tt>.
--   
--   Benchmarking shows the default regex library on many platforms is very
--   inefficient. You might increase performace by an order of magnitude by
--   obtaining <tt>libpcre</tt> and <a>regex-pcre</a> or <tt>libtre</tt>
--   and <a>regex-tre</a>. If you do not need the captured substrings then
--   you can also get great performance from <a>regex-dfa</a>. If you do
--   need the capture substrings then you may be able to use
--   <a>regex-parsec</a> to improve performance.
module Text.Regex.Posix
getVersion_Text_Regex_Posix :: Version

-- | A compiled regular expression.
data Regex

-- | A bitmapped <a>CInt</a> containing options for compilation of regular
--   expressions. Option values (and their man 3 regcomp names) are
--   
--   <ul>
--   <li><a>compBlank</a> which is a completely zero value for all the
--   flags. This is also the <a>blankCompOpt</a> value.</li>
--   <li><a>compExtended</a> (REG_EXTENDED) which can be set to use
--   extended instead of basic regular expressions. This is set in the
--   <a>defaultCompOpt</a> value.</li>
--   <li><a>compNewline</a> (REG_NEWLINE) turns on newline sensitivity: The
--   dot (.) and inverted set <tt>[^ ]</tt> never match newline, and ^ and
--   $ anchors do match after and before newlines. This is set in the
--   <a>defaultCompOpt</a> value.</li>
--   <li><a>compIgnoreCase</a> (REG_ICASE) which can be set to match
--   ignoring upper and lower distinctions.</li>
--   <li><a>compNoSub</a> (REG_NOSUB) which turns off all information from
--   matching except whether a match exists.</li>
--   </ul>
newtype CompOption
CompOption :: CInt -> CompOption

-- | A bitmapped <a>CInt</a> containing options for execution of compiled
--   regular expressions. Option values (and their man 3 regexec names) are
--   
--   <ul>
--   <li><a>execBlank</a> which is a complete zero value for all the flags.
--   This is the <tt>blankExecOpt</tt> value.</li>
--   <li><a>execNotBOL</a> (REG_NOTBOL) can be set to prevent ^ from
--   matching at the start of the input.</li>
--   <li><a>execNotEOL</a> (REG_NOTEOL) can be set to prevent $ from
--   matching at the end of the input (before the terminating NUL).</li>
--   </ul>
newtype ExecOption
ExecOption :: CInt -> ExecOption
(=~) :: (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
(=~~) :: (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target, MonadFail m) => source1 -> source -> m target
unusedRegOffset :: RegOffset

-- | A completely zero value for all the flags. This is also the
--   <a>blankCompOpt</a> value.
compBlank :: CompOption
compExtended :: CompOption
compIgnoreCase :: CompOption
compNoSub :: CompOption
compNewline :: CompOption

-- | A completely zero value for all the flags. This is also the
--   <a>blankExecOpt</a> value.
execBlank :: ExecOption
execNotBOL :: ExecOption
execNotEOL :: ExecOption
