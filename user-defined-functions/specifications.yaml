# Approach:
# - Try to express patterns in terms of BNFC (https://bnfc.digitalgrammars.com/) (with slight modifications)
# - Use <label :: (Type)> expressions to label non-terminals

types:
  - type: Binding
    examples:
      - and ↦ you
patterns:
  - comment: |
      MetaBinding cobines three syntaxes:

      (1) \?B1 ?x.?y... ↦ ?a.b ===> Binding B1 that matches with ?x.?y... ↦ ?a.b, can be used futher as ?B1

      (2) ?bar => \?b_bar ξ.ρ.?b_a.?foo ===>
        in the current formation,
        find a binding with name ?bar where body contains somewhere ξ.ρ.?b_a.?foo,
        and save its whole body to variable ?b_bar

      (3) ?p1..?main ↦ ...     ===> some path to ?main
      (3.1) if used in formation - means enclosure, for ex: ⟦ org ↦ ⟦ eolang ↦ ⟦ main ↦ ... ⟧ ⟧ ⟧
      (3.2) if used in application - means dot notation, for ex (x ↦ org.eolang.main)

      I believe (3) cannot be used without a right side (after ↦) so that I know when to stop searching.

      I think (1) should include (3) as follows.

      (1.1) \?A ?a.?b..c.?d..?e.f ↦ ⟦ ?B ⟧
      (1.2) \?C ?g..h.?i ↦ ?j.k(D).?l..?m.n

      In other words, MetaBinding should allow:
      - optionally saving the full binding to a given metavariable (?A, ?C)
      - matching individual path elements (?a, c, ?e, f, h, ?i)
      - matching a segment of the path (?b.., ?d.., ?g..)
      - matching an object on the right side (⟦ ?C ⟧, ?j.k(D).?l..?m.n)
      - matching a segment of a path within a sequence of dispatches ?l..

      Then
      - (2) is expressible via (1) and $name
      - (3) is expressible via (1) without a metavariable for the full binding
    pattern: |
      MetaBinding. Binding ::= ("\\" <binding :: (MetaId)>)? ((<pathElement :: (Attribute)> ".")* (<segment :: (MetaId)> "..")? (<name :: (Attribute)>) ".")* (<finalName :: (Attribute)>) "↦" <object :: (Object)>
    description: |
      Find a <binding> that has a path to a value after the "↦" that matches a given <object>.
      When <binding> is given, the <binding> equals to the full binding.

      The path can include:
      - individual <pathElement>-s
      - <segment>-s of unknown length

      The path must include:
      - the <finalName> of the last binding
      - the <object> to match after the "↦"
    examples:
      - pattern: '⟦ \?FullBinding ?Path..?Name ↦ ?Object.world(?Bindings) ⟧'
        input: "⟦ org ↦ ⟦ eolang ↦ ⟦ main ↦ hello.world(and ↦ you) ⟧ ⟧ ⟧"
        matches:
          - metavar: "?Path"
            value: ["org", "eolang"]
          - metavar: "?Name"
            value: "main"
          - metavar: "?Object"
            value: "hello"
          - metavar: "?Bindings"
            value: [and ↦ you]
          - metavar: "?PathHead"
            value: ["org"]
          - metavar: "?FullBinding"
            value: [org ↦ ⟦ eolang ↦ ⟦ main ↦ hello.world(and ↦ you) ⟧ ⟧]
        applications:
          - application: $name(?FullBinding)
            value: "org"
        constructions:
          - construction: "⟦ ?FullBinding ⟧"
            value: "⟦ org ↦ ⟦ eolang ↦ ⟦ main ↦ hello.world(and ↦ you) ⟧ ⟧ ⟧"
      - pattern: '(\?FullBinding ?Name ↦ ?DispatchPath..?DispatchName.world)'
        input: "(x ↦ Φ.org.eolang.world, y ↦ Φ.org.eolang.work)"
        matches:
          - metavar: "?FullBinding"
            value: "x ↦ Φ.org.eolang.world"
          - metavar: "?Name"
            value: "x"
          - metavar: "?DispatchPath"
            value: ["Φ", "org"]
          - metavar: "?DispatchName"
            value: "eolang"
        constructions:
          - construction: "⟦ ?FullBinding ⟧"
            value: "⟦ x ↦ Φ.org.eolang.world ⟧"
  - pattern: |
      ExpressionObject. Expression ::= Object
    examples:
      - ξ
      - ⟦ a ↦ ?B ⟧
  - pattern: |
      ExpressionFunction. Expression ::= Function
    examples:
      - $name(?a)
functions:
  - pattern: |
      FunctionMt. Function ::= "$mt" "(" <prefix :: (Expression)> "," <suffix :: (Expression)> ")"
    description: |
      Return the string "<prefix>.<suffix>".
    examples:
      - applications:
          - application: $mt(ξ, $mt(ρ, $mt($name(?b_a), write(α0 ↦ ?t))))
            # Note the result isn't a value because the result contains MetaId-s
            result: ξ.ρ.?b_a.write(α0 ↦ ?t)
  - pattern: |
      FunctionName. Function ::= "$name" "(" <binding :: (MetaId)> ")"
    description: |
      Return the name of <binding>.
    examples:
      - pattern: ⟦ \?Name ?a ↦ ⟦ ?A ⟧ ⟧
        input: ⟦ name ↦ ⟦ a ↦ Φ.a.c, b ↦ Φ.a.c ⟧ ⟧
        matches:
          - metavar: "?Name"
            value: name ↦ ⟦ a ↦ Φ.a.c, b ↦ Φ.a.c ⟧
          - metavar: "?a"
            value: name
        applications:
          - application: $name(?Name)
            value: name
  - pattern: |
      FunctionNames. Function ::= "$names" "(" <bindings :: (MetaId | Function)> ")"
    description: |
      Return the names of <bindings>.
    examples:
      - pattern: "⟦ ?B ⟧"
        input: "⟦ a ↦ Φ.b, c ↦ Φ.c ⟧"
        matches:
          - metavar: "?B"
            value: a ↦ Φ.b, c ↦ Φ.c
        applications:
          - application: $names(?B)
            value: a, c
  - pattern: |
      FunctionReplace. Function ::= "$replace" "(" <e1 :: (MetaId | Expression)> "," <e2 :: (MetaId | Expression)> "," <e3 :: (MetaId | Expression)> ")"
    description: |
      Return <e1> with all occurencies of <e2> replaced with <e3>.
    examples:
      - pattern: ⟦ a ↦ ?B ⟧
        input: ⟦ a ↦ ⟦ a ↦ Φ.a, b ↦ Φ.b, c ↦ Φ.c ⟧ ⟧
        matches:
          - metavar: "?B"
            value: ⟦ a ↦ Φ.a, b ↦ Φ.b, c ↦ Φ.c ⟧
        application: $replace(?B, Φ.b, Φ.baz)
  # FIXME what's the semantics ???
  - pattern: |
      FunctionCombine. Function ::= "$combine" "(" <b1 :: (MetaId)> "," <b2 :: (MetaId)> ")"
    # FIXME order of elements depends on order of bindings in code?
    description: |
      Return new bindings obtained by combining <b1> and <b2>.

      ?B1: [a1 -> x, a2 -> y, a3 -> z]
      ?B2: [b1 -> c, b2 -> d, b3 -> e]
      $combine(?B1, ?B2) => [a1 -> c, a2 -> d, a3 -> e]
    Inspiration 1: array_combine - https://www.php.net/manual/ru/function.array-combine.php
    Inspiration 2: func foo1(int x, string y)
      func foo2(bool z, char a)

      foo1(1, “s”)
      foo2(true, ‘x’)

      func foo_combo(int x, string y, bool z, char a)

      foo_combo(1, “s”, true, ‘x’)
    examples:
      - pattern: ⟦ a ↦ ⟦ ?A ⟧, b ↦ ⟦ ?B ⟧ ⟧
        input: ⟦ a ↦ ⟦ a ↦ Φ.a, b ↦ Φ.b, c ↦ Φ.c ⟧, b ↦ ⟦ d ↦ Φ.d, e ↦ Φ.e ⟧ ⟧
        matches:
          - metavar: "?A"
            value: a ↦ Φ.a, b ↦ Φ.b, c ↦ Φ.c
          - metavar: "?B"
            value: a ↦ Φ.a, d ↦ Φ.d, e ↦ Φ.e
        applications:
          - application: $combine(?A, ?B)
            value: a ↦ Φ.d, b ↦ Φ.e
  # FIXME what's the semantics ???
  - pattern: |
      FunctionUnique. Function ::= "$unique" "(" <bindings :: (MetaId)> ")"
    description: |
      Replace all names in <bindings> with unique names.
    examples:
      - $unique(?B)
  - pattern: |
      FunctionPrefixed. Function ::= $prefixed "(" <name1 :: (Expression)> "," <name2 :: (Expression)> ")"
predicates:
  - pattern: 'PredicateForAll. Predicate ::= "$for-all" "(" <bindings :: (MetaId)> "," <arg :: (MetaId)>, <predicate :: (Predicate)> ")"'
    description: |
      Check that the <predicate> is TRUE for all <bindings>.
      You can use <arg> inside the <predicate>.
    examples: See below
  - pattern: 'PredicateBoundTo. Predicate ::= "$bound-to" "(" <name :: (MetaId)> "," <value :: (Expression)> ")"'
    description: |
      Check that <name> is bound to <value>.
    examples:
      - pattern: "⟦ ?name ↦ Φ.?a.b, ?B ⟧"
        input: ⟦ name ↦ Φ.a.b, a ↦ Φ.a.c, b ↦ Φ.a.c ⟧
        matches:
          - metavar: "?name"
            value: name
          - metavar: "?a"
            value: a
          - metavar: "?B"
            value: a ↦ Φ.a.c, b ↦ Φ.a.c
        where:
          - condition: $bound-to(?name, ∅)
            value: "FALSE"
          - condition: $for-all(?B, ?binding, $bound-to(?binding, Φ.a.c))
            value: "TRUE"
  - pattern: 'PredicateStartsWith. Predicate ::= "$starts-with" "(" <name :: (Expression)> "," <prefix :: (String)> ")"'
    description: |
      Check that <name> starts with <prefix>.
    examples:
      - pattern: '⟦ \?Binding Φ.?a.b, ?Bindings ⟧'
        input: "⟦ name ↦ ⟦ k ↦ Φ.a.b ⟧, a_foo ↦ Φ.a.c, a_bar ↦ Φ.a.c ⟧"
        matches:
          - metavar: "?Binding"
            value: name ↦ ⟦ k ↦ Φ.a.b ⟧
          - metavar: "?Bindings"
            value: a_foo ↦ Φ.a.c, a_bar ↦ Φ.a.c
        where:
          - condition: $for-all(?Bindings, ?binding, $starts-with($name(?binding), "a_"))
            value: TRUE
  - pattern: 'PredicateNot. Predicate ::= "$not" "(" <predicate :: (Predicate)> ")"'
    description: |
      Negate the <predicate>.
    examples:
      - pattern: "⟦ ?name ↦ Φ.?a.b, ?B ⟧"
        input: ⟦ name ↦ Φ.foo.b ⟧
        matches:
          - metavar: "?name"
            value: name
          - metavar: "?a"
            value: foo
          - metavar: "?B"
            value:
        where:
          - condition: $not($starts-with(?a), "foo")
            value: FALSE
          - condition: $not($bound-to(?name, Φ))
            value: TRUE
